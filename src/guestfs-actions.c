/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <stdio.h>
#include <stdlib.h>

#include "guestfs.h"
#include "guestfs_protocol.h"

#define error guestfs_error
#define perrorf guestfs_perrorf
#define safe_malloc guestfs_safe_malloc
#define safe_realloc guestfs_safe_realloc
#define safe_strdup guestfs_safe_strdup
#define safe_memdup guestfs_safe_memdup

/* Check the return message from a call for validity. */
static int
check_reply_header (guestfs_h *g,
                    const struct guestfs_message_header *hdr,
                    int proc_nr, int serial)
{
  if (hdr->prog != GUESTFS_PROGRAM) {
    error (g, "wrong program (%d/%d)", hdr->prog, GUESTFS_PROGRAM);
    return -1;
  }
  if (hdr->vers != GUESTFS_PROTOCOL_VERSION) {
    error (g, "wrong protocol version (%d/%d)",
	   hdr->vers, GUESTFS_PROTOCOL_VERSION);
    return -1;
  }
  if (hdr->direction != GUESTFS_DIRECTION_REPLY) {
    error (g, "unexpected message direction (%d/%d)",
	   hdr->direction, GUESTFS_DIRECTION_REPLY);
    return -1;
  }
  if (hdr->proc != proc_nr) {
    error (g, "unexpected procedure number (%d/%d)", hdr->proc, proc_nr);
    return -1;
  }
  if (hdr->serial != serial) {
    error (g, "unexpected serial (%d/%d)", hdr->serial, serial);
    return -1;
  }

  return 0;
}

/* Check we are in the right state to run a high-level action. */
static int
check_state (guestfs_h *g, const char *caller)
{
  if (!guestfs_is_ready (g)) {
    if (guestfs_is_config (g))
      error (g, "%s: call launch() before using this function",
        caller);
    else if (guestfs_is_launching (g))
      error (g, "%s: call wait_ready() before using this function",
        caller);
    else
      error (g, "%s called from the wrong state, %d != READY",
        caller, guestfs_get_state (g));
    return -1;
  }
  return 0;
}

struct mount_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_ctx *ctx = (struct mount_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_args args;
  struct mount_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT,
        (xdrproc_t) xdr_guestfs_mount_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct sync_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sync_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sync_ctx *ctx = (struct sync_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sync");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sync");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sync");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sync (guestfs_h *g)
{
  struct sync_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sync") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_SYNC, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sync_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sync");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SYNC, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct touch_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void touch_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct touch_ctx *ctx = (struct touch_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_touch");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_touch");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_touch");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_touch (guestfs_h *g,
		const char *path)
{
  struct guestfs_touch_args args;
  struct touch_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_touch") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TOUCH,
        (xdrproc_t) xdr_guestfs_touch_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, touch_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_touch");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TOUCH, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct cat_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_cat_ret ret;
};

static void cat_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct cat_ctx *ctx = (struct cat_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_cat");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_cat");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_cat");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_cat_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_cat");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_cat (guestfs_h *g,
		const char *path)
{
  struct guestfs_cat_args args;
  struct cat_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_cat") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CAT,
        (xdrproc_t) xdr_guestfs_cat_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, cat_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_cat");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CAT, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.content; /* caller will free */
}

struct ll_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ll_ret ret;
};

static void ll_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ll_ctx *ctx = (struct ll_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_ll");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_ll");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_ll");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ll_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_ll");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_ll (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ll_args args;
  struct ll_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ll") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LL,
        (xdrproc_t) xdr_guestfs_ll_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, ll_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_ll");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LL, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.listing; /* caller will free */
}

struct ls_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ls_ret ret;
};

static void ls_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ls_ctx *ctx = (struct ls_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_ls");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_ls");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_ls");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ls_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_ls");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_ls (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ls_args args;
  struct ls_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ls") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LS,
        (xdrproc_t) xdr_guestfs_ls_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, ls_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_ls");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.listing.listing_val =
    safe_realloc (g, ctx.ret.listing.listing_val,
                  sizeof (char *) * (ctx.ret.listing.listing_len + 1));
  ctx.ret.listing.listing_val[ctx.ret.listing.listing_len] = NULL;
  return ctx.ret.listing.listing_val;
}

struct list_devices_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_devices_ret ret;
};

static void list_devices_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct list_devices_ctx *ctx = (struct list_devices_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_list_devices");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_list_devices");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_list_devices");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_devices_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_list_devices");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_list_devices (guestfs_h *g)
{
  struct list_devices_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_list_devices") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LIST_DEVICES, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, list_devices_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_list_devices");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LIST_DEVICES, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.devices.devices_val =
    safe_realloc (g, ctx.ret.devices.devices_val,
                  sizeof (char *) * (ctx.ret.devices.devices_len + 1));
  ctx.ret.devices.devices_val[ctx.ret.devices.devices_len] = NULL;
  return ctx.ret.devices.devices_val;
}

struct list_partitions_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_partitions_ret ret;
};

static void list_partitions_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct list_partitions_ctx *ctx = (struct list_partitions_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_list_partitions");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_list_partitions");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_list_partitions");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_partitions_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_list_partitions");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_list_partitions (guestfs_h *g)
{
  struct list_partitions_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_list_partitions") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LIST_PARTITIONS, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, list_partitions_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_list_partitions");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LIST_PARTITIONS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.partitions.partitions_val =
    safe_realloc (g, ctx.ret.partitions.partitions_val,
                  sizeof (char *) * (ctx.ret.partitions.partitions_len + 1));
  ctx.ret.partitions.partitions_val[ctx.ret.partitions.partitions_len] = NULL;
  return ctx.ret.partitions.partitions_val;
}

struct pvs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_ret ret;
};

static void pvs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvs_ctx *ctx = (struct pvs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_pvs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_pvs (guestfs_h *g)
{
  struct pvs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_PVS, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvs");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.physvols.physvols_val =
    safe_realloc (g, ctx.ret.physvols.physvols_val,
                  sizeof (char *) * (ctx.ret.physvols.physvols_len + 1));
  ctx.ret.physvols.physvols_val[ctx.ret.physvols.physvols_len] = NULL;
  return ctx.ret.physvols.physvols_val;
}

struct vgs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_ret ret;
};

static void vgs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgs_ctx *ctx = (struct vgs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_vgs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_vgs (guestfs_h *g)
{
  struct vgs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_VGS, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgs");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.volgroups.volgroups_val =
    safe_realloc (g, ctx.ret.volgroups.volgroups_val,
                  sizeof (char *) * (ctx.ret.volgroups.volgroups_len + 1));
  ctx.ret.volgroups.volgroups_val[ctx.ret.volgroups.volgroups_len] = NULL;
  return ctx.ret.volgroups.volgroups_val;
}

struct lvs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_ret ret;
};

static void lvs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvs_ctx *ctx = (struct lvs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_lvs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_lvs (guestfs_h *g)
{
  struct lvs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LVS, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvs");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.logvols.logvols_val =
    safe_realloc (g, ctx.ret.logvols.logvols_val,
                  sizeof (char *) * (ctx.ret.logvols.logvols_len + 1));
  ctx.ret.logvols.logvols_val[ctx.ret.logvols.logvols_len] = NULL;
  return ctx.ret.logvols.logvols_val;
}

struct pvs_full_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_full_ret ret;
};

static void pvs_full_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvs_full_ctx *ctx = (struct pvs_full_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvs_full");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvs_full");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvs_full");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_full_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_pvs_full");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *g)
{
  struct pvs_full_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvs_full") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_PVS_FULL, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvs_full_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvs_full");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVS_FULL, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.physvols, sizeof (ctx.ret.physvols));
}

struct vgs_full_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_full_ret ret;
};

static void vgs_full_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgs_full_ctx *ctx = (struct vgs_full_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgs_full");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgs_full");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgs_full");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_full_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_vgs_full");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *g)
{
  struct vgs_full_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgs_full") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_VGS_FULL, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgs_full_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgs_full");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGS_FULL, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.volgroups, sizeof (ctx.ret.volgroups));
}

struct lvs_full_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_full_ret ret;
};

static void lvs_full_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvs_full_ctx *ctx = (struct lvs_full_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvs_full");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvs_full");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvs_full");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_full_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_lvs_full");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *g)
{
  struct lvs_full_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvs_full") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LVS_FULL, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvs_full_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvs_full");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVS_FULL, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.logvols, sizeof (ctx.ret.logvols));
}

struct read_lines_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_read_lines_ret ret;
};

static void read_lines_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct read_lines_ctx *ctx = (struct read_lines_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_read_lines");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_read_lines");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_read_lines");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_read_lines_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_read_lines");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_read_lines (guestfs_h *g,
		const char *path)
{
  struct guestfs_read_lines_args args;
  struct read_lines_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_read_lines") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_READ_LINES,
        (xdrproc_t) xdr_guestfs_read_lines_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, read_lines_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_read_lines");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_READ_LINES, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct aug_init_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_init_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_init_ctx *ctx = (struct aug_init_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_init");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_init");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_init");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_init (guestfs_h *g,
		const char *root,
		int flags)
{
  struct guestfs_aug_init_args args;
  struct aug_init_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_init") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.root = (char *) root;
  args.flags = flags;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_INIT,
        (xdrproc_t) xdr_guestfs_aug_init_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_init_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_init");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_INIT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_close_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_close_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_close_ctx *ctx = (struct aug_close_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_close");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_close");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_close");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_close (guestfs_h *g)
{
  struct aug_close_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_close") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_CLOSE, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_close_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_close");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_CLOSE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_defvar_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defvar_ret ret;
};

static void aug_defvar_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_defvar_ctx *ctx = (struct aug_defvar_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_defvar");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_defvar");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_defvar");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defvar_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_defvar");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_defvar (guestfs_h *g,
		const char *name,
		const char *expr)
{
  struct guestfs_aug_defvar_args args;
  struct aug_defvar_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_defvar") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.name = (char *) name;
  args.expr = expr ? (char **) &expr : NULL;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_DEFVAR,
        (xdrproc_t) xdr_guestfs_aug_defvar_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_defvar_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_defvar");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_DEFVAR, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.nrnodes;
}

struct aug_defnode_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defnode_ret ret;
};

static void aug_defnode_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_defnode_ctx *ctx = (struct aug_defnode_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_defnode");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_defnode");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_defnode");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defnode_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_defnode");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *g,
		const char *name,
		const char *expr,
		const char *val)
{
  struct guestfs_aug_defnode_args args;
  struct aug_defnode_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_defnode") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.name = (char *) name;
  args.expr = (char *) expr;
  args.val = (char *) val;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_DEFNODE,
        (xdrproc_t) xdr_guestfs_aug_defnode_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_defnode_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_defnode");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_DEFNODE, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller with free this */
  return safe_memdup (g, &ctx.ret, sizeof (ctx.ret));
}

struct aug_get_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_get_ret ret;
};

static void aug_get_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_get_ctx *ctx = (struct aug_get_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_get");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_get");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_get");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_get_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_get");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_aug_get (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_get_args args;
  struct aug_get_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_get") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_GET,
        (xdrproc_t) xdr_guestfs_aug_get_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_get_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_get");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_GET, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.val; /* caller will free */
}

struct aug_set_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_set_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_set_ctx *ctx = (struct aug_set_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_set");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_set");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_set");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_set (guestfs_h *g,
		const char *path,
		const char *val)
{
  struct guestfs_aug_set_args args;
  struct aug_set_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_set") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  args.val = (char *) val;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_SET,
        (xdrproc_t) xdr_guestfs_aug_set_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_set_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_set");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_SET, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_insert_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_insert_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_insert_ctx *ctx = (struct aug_insert_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_insert");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_insert");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_insert");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_insert (guestfs_h *g,
		const char *path,
		const char *label,
		int before)
{
  struct guestfs_aug_insert_args args;
  struct aug_insert_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_insert") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  args.label = (char *) label;
  args.before = before;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_INSERT,
        (xdrproc_t) xdr_guestfs_aug_insert_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_insert_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_insert");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_INSERT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_rm_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_rm_ret ret;
};

static void aug_rm_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_rm_ctx *ctx = (struct aug_rm_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_rm");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_rm");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_rm");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_rm_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_rm");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_rm_args args;
  struct aug_rm_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_rm") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_RM,
        (xdrproc_t) xdr_guestfs_aug_rm_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_rm_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_rm");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_RM, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.nrnodes;
}

struct aug_mv_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_mv_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_mv_ctx *ctx = (struct aug_mv_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_mv");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_mv");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_mv");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_mv (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_aug_mv_args args;
  struct aug_mv_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_mv") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_MV,
        (xdrproc_t) xdr_guestfs_aug_mv_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_mv_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_mv");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_MV, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_match_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_match_ret ret;
};

static void aug_match_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_match_ctx *ctx = (struct aug_match_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_match");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_match");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_match");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_match_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_match");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_aug_match (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_match_args args;
  struct aug_match_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_match") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_MATCH,
        (xdrproc_t) xdr_guestfs_aug_match_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_match_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_match");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_MATCH, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.matches.matches_val =
    safe_realloc (g, ctx.ret.matches.matches_val,
                  sizeof (char *) * (ctx.ret.matches.matches_len + 1));
  ctx.ret.matches.matches_val[ctx.ret.matches.matches_len] = NULL;
  return ctx.ret.matches.matches_val;
}

struct aug_save_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_save_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_save_ctx *ctx = (struct aug_save_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_save");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_save");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_save");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_save (guestfs_h *g)
{
  struct aug_save_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_save") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_SAVE, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_save_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_save");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_SAVE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_load_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_load_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_load_ctx *ctx = (struct aug_load_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_load");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_load");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_load");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_load (guestfs_h *g)
{
  struct aug_load_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_load") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_LOAD, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_load_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_load");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_LOAD, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct aug_ls_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_ls_ret ret;
};

static void aug_ls_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_ls_ctx *ctx = (struct aug_ls_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_ls");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_ls");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_ls");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_ls_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_ls");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_aug_ls (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_ls_args args;
  struct aug_ls_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_ls") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_LS,
        (xdrproc_t) xdr_guestfs_aug_ls_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_ls_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_ls");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_LS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.matches.matches_val =
    safe_realloc (g, ctx.ret.matches.matches_val,
                  sizeof (char *) * (ctx.ret.matches.matches_len + 1));
  ctx.ret.matches.matches_val[ctx.ret.matches.matches_len] = NULL;
  return ctx.ret.matches.matches_val;
}

struct rm_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rm_ctx *ctx = (struct rm_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_rm");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_rm");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_rm");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_args args;
  struct rm_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rm") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RM,
        (xdrproc_t) xdr_guestfs_rm_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, rm_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_rm");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RM, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct rmdir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rmdir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rmdir_ctx *ctx = (struct rmdir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_rmdir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_rmdir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_rmdir");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_rmdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_rmdir_args args;
  struct rmdir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rmdir") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RMDIR,
        (xdrproc_t) xdr_guestfs_rmdir_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, rmdir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_rmdir");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RMDIR, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct rm_rf_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_rf_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rm_rf_ctx *ctx = (struct rm_rf_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_rm_rf");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_rm_rf");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_rm_rf");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_rm_rf (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_rf_args args;
  struct rm_rf_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rm_rf") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RM_RF,
        (xdrproc_t) xdr_guestfs_rm_rf_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, rm_rf_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_rm_rf");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RM_RF, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mkdir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdir_ctx *ctx = (struct mkdir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkdir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkdir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkdir");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_args args;
  struct mkdir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdir") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKDIR,
        (xdrproc_t) xdr_guestfs_mkdir_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkdir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkdir");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKDIR, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mkdir_p_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_p_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdir_p_ctx *ctx = (struct mkdir_p_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkdir_p");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkdir_p");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkdir_p");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkdir_p (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_p_args args;
  struct mkdir_p_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdir_p") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKDIR_P,
        (xdrproc_t) xdr_guestfs_mkdir_p_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkdir_p_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkdir_p");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKDIR_P, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct chmod_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chmod_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct chmod_ctx *ctx = (struct chmod_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_chmod");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_chmod");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_chmod");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_chmod (guestfs_h *g,
		int mode,
		const char *path)
{
  struct guestfs_chmod_args args;
  struct chmod_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_chmod") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mode = mode;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CHMOD,
        (xdrproc_t) xdr_guestfs_chmod_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, chmod_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_chmod");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CHMOD, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct chown_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chown_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct chown_ctx *ctx = (struct chown_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_chown");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_chown");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_chown");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_chown (guestfs_h *g,
		int owner,
		int group,
		const char *path)
{
  struct guestfs_chown_args args;
  struct chown_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_chown") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.owner = owner;
  args.group = group;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CHOWN,
        (xdrproc_t) xdr_guestfs_chown_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, chown_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_chown");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CHOWN, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct exists_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_exists_ret ret;
};

static void exists_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct exists_ctx *ctx = (struct exists_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_exists");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_exists");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_exists");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_exists_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_exists");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_exists (guestfs_h *g,
		const char *path)
{
  struct guestfs_exists_args args;
  struct exists_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_exists") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_EXISTS,
        (xdrproc_t) xdr_guestfs_exists_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, exists_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_exists");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_EXISTS, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.existsflag;
}

struct is_file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_file_ret ret;
};

static void is_file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct is_file_ctx *ctx = (struct is_file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_is_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_is_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_is_file");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_file_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_is_file");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_is_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_file_args args;
  struct is_file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_is_file") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_IS_FILE,
        (xdrproc_t) xdr_guestfs_is_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, is_file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_is_file");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_IS_FILE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.fileflag;
}

struct is_dir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_dir_ret ret;
};

static void is_dir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct is_dir_ctx *ctx = (struct is_dir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_is_dir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_is_dir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_is_dir");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_dir_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_is_dir");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_is_dir (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_dir_args args;
  struct is_dir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_is_dir") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_IS_DIR,
        (xdrproc_t) xdr_guestfs_is_dir_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, is_dir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_is_dir");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_IS_DIR, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.dirflag;
}

struct pvcreate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvcreate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvcreate_ctx *ctx = (struct pvcreate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvcreate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvcreate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvcreate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_pvcreate (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvcreate_args args;
  struct pvcreate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvcreate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_PVCREATE,
        (xdrproc_t) xdr_guestfs_pvcreate_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvcreate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvcreate");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVCREATE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct vgcreate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vgcreate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgcreate_ctx *ctx = (struct vgcreate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgcreate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgcreate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgcreate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_vgcreate (guestfs_h *g,
		const char *volgroup,
		char * const* const physvols)
{
  struct guestfs_vgcreate_args args;
  struct vgcreate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgcreate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.volgroup = (char *) volgroup;
  args.physvols.physvols_val = (char **) physvols;
  for (args.physvols.physvols_len = 0; physvols[args.physvols.physvols_len]; args.physvols.physvols_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_VGCREATE,
        (xdrproc_t) xdr_guestfs_vgcreate_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgcreate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgcreate");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGCREATE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct lvcreate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvcreate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvcreate_ctx *ctx = (struct lvcreate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvcreate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvcreate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvcreate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvcreate (guestfs_h *g,
		const char *logvol,
		const char *volgroup,
		int mbytes)
{
  struct guestfs_lvcreate_args args;
  struct lvcreate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvcreate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.logvol = (char *) logvol;
  args.volgroup = (char *) volgroup;
  args.mbytes = mbytes;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LVCREATE,
        (xdrproc_t) xdr_guestfs_lvcreate_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvcreate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvcreate");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVCREATE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mkfs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkfs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkfs_ctx *ctx = (struct mkfs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkfs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkfs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkfs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkfs (guestfs_h *g,
		const char *fstype,
		const char *device)
{
  struct guestfs_mkfs_args args;
  struct mkfs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkfs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.fstype = (char *) fstype;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKFS,
        (xdrproc_t) xdr_guestfs_mkfs_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkfs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkfs");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKFS, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct sfdisk_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sfdisk_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_ctx *ctx = (struct sfdisk_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdisk");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdisk");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdisk");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sfdisk (guestfs_h *g,
		const char *device,
		int cyls,
		int heads,
		int sectors,
		char * const* const lines)
{
  struct guestfs_sfdisk_args args;
  struct sfdisk_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.cyls = cyls;
  args.heads = heads;
  args.sectors = sectors;
  args.lines.lines_val = (char **) lines;
  for (args.lines.lines_len = 0; lines[args.lines.lines_len]; args.lines.lines_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISK,
        (xdrproc_t) xdr_guestfs_sfdisk_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdisk_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdisk");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISK, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct write_file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void write_file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct write_file_ctx *ctx = (struct write_file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_write_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_write_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_write_file");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_write_file (guestfs_h *g,
		const char *path,
		const char *content,
		int size)
{
  struct guestfs_write_file_args args;
  struct write_file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_write_file") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  args.content = (char *) content;
  args.size = size;
  serial = guestfs__send_sync (g, GUESTFS_PROC_WRITE_FILE,
        (xdrproc_t) xdr_guestfs_write_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, write_file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_write_file");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_WRITE_FILE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct umount_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umount_ctx *ctx = (struct umount_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_umount");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_umount");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_umount");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_umount (guestfs_h *g,
		const char *pathordevice)
{
  struct guestfs_umount_args args;
  struct umount_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umount") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.pathordevice = (char *) pathordevice;
  serial = guestfs__send_sync (g, GUESTFS_PROC_UMOUNT,
        (xdrproc_t) xdr_guestfs_umount_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, umount_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_umount");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UMOUNT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mounts_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_mounts_ret ret;
};

static void mounts_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mounts_ctx *ctx = (struct mounts_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mounts");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mounts");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mounts");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_mounts_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_mounts");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_mounts (guestfs_h *g)
{
  struct mounts_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mounts") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNTS, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mounts_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mounts");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNTS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.devices.devices_val =
    safe_realloc (g, ctx.ret.devices.devices_val,
                  sizeof (char *) * (ctx.ret.devices.devices_len + 1));
  ctx.ret.devices.devices_val[ctx.ret.devices.devices_len] = NULL;
  return ctx.ret.devices.devices_val;
}

struct umount_all_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_all_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umount_all_ctx *ctx = (struct umount_all_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_umount_all");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_umount_all");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_umount_all");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_umount_all (guestfs_h *g)
{
  struct umount_all_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umount_all") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_UMOUNT_ALL, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, umount_all_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_umount_all");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UMOUNT_ALL, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct lvm_remove_all_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvm_remove_all_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvm_remove_all_ctx *ctx = (struct lvm_remove_all_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvm_remove_all");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvm_remove_all");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvm_remove_all");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvm_remove_all (guestfs_h *g)
{
  struct lvm_remove_all_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvm_remove_all") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LVM_REMOVE_ALL, NULL, NULL);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvm_remove_all_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvm_remove_all");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVM_REMOVE_ALL, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_file_ret ret;
};

static void file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct file_ctx *ctx = (struct file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_file");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_file_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_file");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_file_args args;
  struct file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_file") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_FILE,
        (xdrproc_t) xdr_guestfs_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_file");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_FILE, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.description; /* caller will free */
}

struct command_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_ret ret;
};

static void command_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct command_ctx *ctx = (struct command_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_command");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_command");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_command");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_command");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_command (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_args args;
  struct command_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_command") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_COMMAND,
        (xdrproc_t) xdr_guestfs_command_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, command_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_command");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_COMMAND, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.output; /* caller will free */
}

struct command_lines_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_lines_ret ret;
};

static void command_lines_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct command_lines_ctx *ctx = (struct command_lines_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_command_lines");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_command_lines");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_command_lines");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_lines_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_command_lines");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_command_lines (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_lines_args args;
  struct command_lines_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_command_lines") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_COMMAND_LINES,
        (xdrproc_t) xdr_guestfs_command_lines_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, command_lines_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_command_lines");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_COMMAND_LINES, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct stat_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_stat_ret ret;
};

static void stat_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct stat_ctx *ctx = (struct stat_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_stat");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_stat");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_stat");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_stat_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_stat");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_stat *guestfs_stat (guestfs_h *g,
		const char *path)
{
  struct guestfs_stat_args args;
  struct stat_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_stat") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_STAT,
        (xdrproc_t) xdr_guestfs_stat_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, stat_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_stat");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_STAT, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.statbuf, sizeof (ctx.ret.statbuf));
}

struct lstat_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lstat_ret ret;
};

static void lstat_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lstat_ctx *ctx = (struct lstat_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lstat");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lstat");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lstat");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lstat_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_lstat");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_stat *guestfs_lstat (guestfs_h *g,
		const char *path)
{
  struct guestfs_lstat_args args;
  struct lstat_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lstat") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LSTAT,
        (xdrproc_t) xdr_guestfs_lstat_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lstat_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lstat");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LSTAT, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.statbuf, sizeof (ctx.ret.statbuf));
}

struct statvfs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_statvfs_ret ret;
};

static void statvfs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct statvfs_ctx *ctx = (struct statvfs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_statvfs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_statvfs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_statvfs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_statvfs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_statvfs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_statvfs *guestfs_statvfs (guestfs_h *g,
		const char *path)
{
  struct guestfs_statvfs_args args;
  struct statvfs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_statvfs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_STATVFS,
        (xdrproc_t) xdr_guestfs_statvfs_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, statvfs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_statvfs");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_STATVFS, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.statbuf, sizeof (ctx.ret.statbuf));
}

struct tune2fs_l_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_tune2fs_l_ret ret;
};

static void tune2fs_l_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tune2fs_l_ctx *ctx = (struct tune2fs_l_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tune2fs_l");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tune2fs_l");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tune2fs_l");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_tune2fs_l_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_tune2fs_l");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_tune2fs_l (guestfs_h *g,
		const char *device)
{
  struct guestfs_tune2fs_l_args args;
  struct tune2fs_l_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tune2fs_l") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TUNE2FS_L,
        (xdrproc_t) xdr_guestfs_tune2fs_l_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tune2fs_l_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tune2fs_l");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TUNE2FS_L, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.superblock.superblock_val =
    safe_realloc (g, ctx.ret.superblock.superblock_val,
                  sizeof (char *) * (ctx.ret.superblock.superblock_len + 1));
  ctx.ret.superblock.superblock_val[ctx.ret.superblock.superblock_len] = NULL;
  return ctx.ret.superblock.superblock_val;
}

struct blockdev_setro_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setro_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setro_ctx *ctx = (struct blockdev_setro_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_setro");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_setro");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_setro");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_setro (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_setro_args args;
  struct blockdev_setro_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setro") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_SETRO,
        (xdrproc_t) xdr_guestfs_blockdev_setro_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_setro_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_setro");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_SETRO, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct blockdev_setrw_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setrw_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setrw_ctx *ctx = (struct blockdev_setrw_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_setrw");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_setrw");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_setrw");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_setrw (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_setrw_args args;
  struct blockdev_setrw_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setrw") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_SETRW,
        (xdrproc_t) xdr_guestfs_blockdev_setrw_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_setrw_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_setrw");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_SETRW, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct blockdev_getro_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getro_ret ret;
};

static void blockdev_getro_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getro_ctx *ctx = (struct blockdev_getro_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getro");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getro");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getro");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getro_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getro");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_getro (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getro_args args;
  struct blockdev_getro_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getro") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETRO,
        (xdrproc_t) xdr_guestfs_blockdev_getro_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getro_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getro");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETRO, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.ro;
}

struct blockdev_getss_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getss_ret ret;
};

static void blockdev_getss_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getss_ctx *ctx = (struct blockdev_getss_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getss");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getss");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getss");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getss_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getss");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_getss (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getss_args args;
  struct blockdev_getss_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getss") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETSS,
        (xdrproc_t) xdr_guestfs_blockdev_getss_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getss_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getss");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETSS, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.sectorsize;
}

struct blockdev_getbsz_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getbsz_ret ret;
};

static void blockdev_getbsz_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getbsz_ctx *ctx = (struct blockdev_getbsz_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getbsz");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getbsz");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getbsz");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getbsz_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getbsz");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_getbsz (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getbsz_args args;
  struct blockdev_getbsz_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getbsz") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETBSZ,
        (xdrproc_t) xdr_guestfs_blockdev_getbsz_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getbsz_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getbsz");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETBSZ, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.blocksize;
}

struct blockdev_setbsz_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setbsz_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setbsz_ctx *ctx = (struct blockdev_setbsz_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_setbsz");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_setbsz");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_setbsz");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_setbsz (guestfs_h *g,
		const char *device,
		int blocksize)
{
  struct guestfs_blockdev_setbsz_args args;
  struct blockdev_setbsz_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setbsz") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.blocksize = blocksize;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_SETBSZ,
        (xdrproc_t) xdr_guestfs_blockdev_setbsz_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_setbsz_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_setbsz");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_SETBSZ, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct blockdev_getsz_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getsz_ret ret;
};

static void blockdev_getsz_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getsz_ctx *ctx = (struct blockdev_getsz_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getsz");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getsz");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getsz");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getsz_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getsz");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int64_t guestfs_blockdev_getsz (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getsz_args args;
  struct blockdev_getsz_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getsz") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETSZ,
        (xdrproc_t) xdr_guestfs_blockdev_getsz_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getsz_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getsz");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETSZ, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.sizeinsectors;
}

struct blockdev_getsize64_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getsize64_ret ret;
};

static void blockdev_getsize64_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getsize64_ctx *ctx = (struct blockdev_getsize64_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getsize64");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getsize64");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getsize64");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getsize64_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getsize64");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int64_t guestfs_blockdev_getsize64 (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getsize64_args args;
  struct blockdev_getsize64_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getsize64") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETSIZE64,
        (xdrproc_t) xdr_guestfs_blockdev_getsize64_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getsize64_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getsize64");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETSIZE64, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.sizeinbytes;
}

struct blockdev_flushbufs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_flushbufs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_flushbufs_ctx *ctx = (struct blockdev_flushbufs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_flushbufs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_flushbufs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_flushbufs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_flushbufs (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_flushbufs_args args;
  struct blockdev_flushbufs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_flushbufs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_FLUSHBUFS,
        (xdrproc_t) xdr_guestfs_blockdev_flushbufs_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_flushbufs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_flushbufs");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_FLUSHBUFS, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct blockdev_rereadpt_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_rereadpt_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_rereadpt_ctx *ctx = (struct blockdev_rereadpt_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_rereadpt");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_rereadpt");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_rereadpt");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_rereadpt (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_rereadpt_args args;
  struct blockdev_rereadpt_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_rereadpt") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_REREADPT,
        (xdrproc_t) xdr_guestfs_blockdev_rereadpt_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_rereadpt_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_rereadpt");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_REREADPT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct upload_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void upload_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct upload_ctx *ctx = (struct upload_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_upload");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_upload");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_upload");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_upload (guestfs_h *g,
		const char *filename,
		const char *remotefilename)
{
  struct guestfs_upload_args args;
  struct upload_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_upload") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.remotefilename = (char *) remotefilename;
  serial = guestfs__send_sync (g, GUESTFS_PROC_UPLOAD,
        (xdrproc_t) xdr_guestfs_upload_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  {
    int r;

    r = guestfs__send_file_sync (g, filename);
    if (r == -1) {
      guestfs_set_ready (g);
      return -1;
    }
    if (r == -2) /* daemon cancelled */
      goto read_reply;
  }

 read_reply:
  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, upload_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_upload");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UPLOAD, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct download_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void download_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct download_ctx *ctx = (struct download_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_download");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_download");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_download");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_download (guestfs_h *g,
		const char *remotefilename,
		const char *filename)
{
  struct guestfs_download_args args;
  struct download_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_download") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.remotefilename = (char *) remotefilename;
  serial = guestfs__send_sync (g, GUESTFS_PROC_DOWNLOAD,
        (xdrproc_t) xdr_guestfs_download_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, download_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_download");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DOWNLOAD, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  if (guestfs__receive_file_sync (g, filename) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct checksum_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_checksum_ret ret;
};

static void checksum_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct checksum_ctx *ctx = (struct checksum_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_checksum");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_checksum");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_checksum");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_checksum_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_checksum");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_checksum (guestfs_h *g,
		const char *csumtype,
		const char *path)
{
  struct guestfs_checksum_args args;
  struct checksum_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_checksum") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.csumtype = (char *) csumtype;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CHECKSUM,
        (xdrproc_t) xdr_guestfs_checksum_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, checksum_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_checksum");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CHECKSUM, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.checksum; /* caller will free */
}

struct tar_in_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tar_in_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tar_in_ctx *ctx = (struct tar_in_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tar_in");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tar_in");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tar_in");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tar_in (guestfs_h *g,
		const char *tarfile,
		const char *directory)
{
  struct guestfs_tar_in_args args;
  struct tar_in_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tar_in") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TAR_IN,
        (xdrproc_t) xdr_guestfs_tar_in_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  {
    int r;

    r = guestfs__send_file_sync (g, tarfile);
    if (r == -1) {
      guestfs_set_ready (g);
      return -1;
    }
    if (r == -2) /* daemon cancelled */
      goto read_reply;
  }

 read_reply:
  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tar_in_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tar_in");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TAR_IN, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct tar_out_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tar_out_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tar_out_ctx *ctx = (struct tar_out_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tar_out");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tar_out");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tar_out");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tar_out (guestfs_h *g,
		const char *directory,
		const char *tarfile)
{
  struct guestfs_tar_out_args args;
  struct tar_out_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tar_out") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TAR_OUT,
        (xdrproc_t) xdr_guestfs_tar_out_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tar_out_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tar_out");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TAR_OUT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  if (guestfs__receive_file_sync (g, tarfile) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct tgz_in_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tgz_in_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tgz_in_ctx *ctx = (struct tgz_in_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tgz_in");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tgz_in");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tgz_in");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tgz_in (guestfs_h *g,
		const char *tarball,
		const char *directory)
{
  struct guestfs_tgz_in_args args;
  struct tgz_in_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tgz_in") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TGZ_IN,
        (xdrproc_t) xdr_guestfs_tgz_in_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  {
    int r;

    r = guestfs__send_file_sync (g, tarball);
    if (r == -1) {
      guestfs_set_ready (g);
      return -1;
    }
    if (r == -2) /* daemon cancelled */
      goto read_reply;
  }

 read_reply:
  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tgz_in_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tgz_in");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TGZ_IN, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct tgz_out_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tgz_out_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tgz_out_ctx *ctx = (struct tgz_out_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tgz_out");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tgz_out");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tgz_out");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tgz_out (guestfs_h *g,
		const char *directory,
		const char *tarball)
{
  struct guestfs_tgz_out_args args;
  struct tgz_out_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tgz_out") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TGZ_OUT,
        (xdrproc_t) xdr_guestfs_tgz_out_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tgz_out_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tgz_out");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TGZ_OUT, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  if (guestfs__receive_file_sync (g, tarball) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mount_ro_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_ro_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_ro_ctx *ctx = (struct mount_ro_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_ro");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_ro");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_ro");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_ro (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_ro_args args;
  struct mount_ro_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_ro") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_RO,
        (xdrproc_t) xdr_guestfs_mount_ro_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_ro_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_ro");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_RO, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mount_options_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_options_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_options_ctx *ctx = (struct mount_options_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_options");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_options");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_options");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_options (guestfs_h *g,
		const char *options,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_options_args args;
  struct mount_options_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_options") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.options = (char *) options;
  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_OPTIONS,
        (xdrproc_t) xdr_guestfs_mount_options_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_options_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_options");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_OPTIONS, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct mount_vfs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_vfs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_vfs_ctx *ctx = (struct mount_vfs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_vfs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_vfs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_vfs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_vfs (guestfs_h *g,
		const char *options,
		const char *vfstype,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_vfs_args args;
  struct mount_vfs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_vfs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.options = (char *) options;
  args.vfstype = (char *) vfstype;
  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_VFS,
        (xdrproc_t) xdr_guestfs_mount_vfs_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_vfs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_vfs");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_VFS, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct debug_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_debug_ret ret;
};

static void debug_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct debug_ctx *ctx = (struct debug_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_debug");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_debug");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_debug");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_debug_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_debug");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_debug (guestfs_h *g,
		const char *subcmd,
		char * const* const extraargs)
{
  struct guestfs_debug_args args;
  struct debug_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_debug") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.subcmd = (char *) subcmd;
  args.extraargs.extraargs_val = (char **) extraargs;
  for (args.extraargs.extraargs_len = 0; extraargs[args.extraargs.extraargs_len]; args.extraargs.extraargs_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_DEBUG,
        (xdrproc_t) xdr_guestfs_debug_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, debug_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_debug");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DEBUG, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.result; /* caller will free */
}

struct lvremove_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvremove_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvremove_ctx *ctx = (struct lvremove_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvremove");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvremove");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvremove");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvremove (guestfs_h *g,
		const char *device)
{
  struct guestfs_lvremove_args args;
  struct lvremove_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvremove") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LVREMOVE,
        (xdrproc_t) xdr_guestfs_lvremove_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvremove_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvremove");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVREMOVE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct vgremove_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vgremove_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgremove_ctx *ctx = (struct vgremove_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgremove");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgremove");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgremove");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_vgremove (guestfs_h *g,
		const char *vgname)
{
  struct guestfs_vgremove_args args;
  struct vgremove_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgremove") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.vgname = (char *) vgname;
  serial = guestfs__send_sync (g, GUESTFS_PROC_VGREMOVE,
        (xdrproc_t) xdr_guestfs_vgremove_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgremove_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgremove");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGREMOVE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct pvremove_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvremove_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvremove_ctx *ctx = (struct pvremove_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvremove");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvremove");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvremove");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_pvremove (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvremove_args args;
  struct pvremove_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvremove") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_PVREMOVE,
        (xdrproc_t) xdr_guestfs_pvremove_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvremove_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvremove");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVREMOVE, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct set_e2label_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void set_e2label_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct set_e2label_ctx *ctx = (struct set_e2label_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_set_e2label");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_set_e2label");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_set_e2label");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_set_e2label (guestfs_h *g,
		const char *device,
		const char *label)
{
  struct guestfs_set_e2label_args args;
  struct set_e2label_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_set_e2label") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.label = (char *) label;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SET_E2LABEL,
        (xdrproc_t) xdr_guestfs_set_e2label_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, set_e2label_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_set_e2label");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SET_E2LABEL, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct get_e2label_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_get_e2label_ret ret;
};

static void get_e2label_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct get_e2label_ctx *ctx = (struct get_e2label_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_get_e2label");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_get_e2label");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_get_e2label");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_get_e2label_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_get_e2label");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_get_e2label (guestfs_h *g,
		const char *device)
{
  struct guestfs_get_e2label_args args;
  struct get_e2label_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_get_e2label") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GET_E2LABEL,
        (xdrproc_t) xdr_guestfs_get_e2label_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, get_e2label_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_get_e2label");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GET_E2LABEL, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.label; /* caller will free */
}

struct set_e2uuid_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void set_e2uuid_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct set_e2uuid_ctx *ctx = (struct set_e2uuid_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_set_e2uuid");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_set_e2uuid");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_set_e2uuid");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_set_e2uuid (guestfs_h *g,
		const char *device,
		const char *uuid)
{
  struct guestfs_set_e2uuid_args args;
  struct set_e2uuid_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_set_e2uuid") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.uuid = (char *) uuid;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SET_E2UUID,
        (xdrproc_t) xdr_guestfs_set_e2uuid_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, set_e2uuid_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_set_e2uuid");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SET_E2UUID, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct get_e2uuid_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_get_e2uuid_ret ret;
};

static void get_e2uuid_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct get_e2uuid_ctx *ctx = (struct get_e2uuid_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_get_e2uuid");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_get_e2uuid");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_get_e2uuid");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_get_e2uuid_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_get_e2uuid");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_get_e2uuid (guestfs_h *g,
		const char *device)
{
  struct guestfs_get_e2uuid_args args;
  struct get_e2uuid_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_get_e2uuid") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GET_E2UUID,
        (xdrproc_t) xdr_guestfs_get_e2uuid_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, get_e2uuid_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_get_e2uuid");
    guestfs_set_ready (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GET_E2UUID, serial) == -1) {
    guestfs_set_ready (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return NULL;
  }

  guestfs_set_ready (g);
  return ctx.ret.uuid; /* caller will free */
}

struct fsck_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_fsck_ret ret;
};

static void fsck_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct fsck_ctx *ctx = (struct fsck_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_fsck");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_fsck");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_fsck");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_fsck_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_fsck");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_fsck (guestfs_h *g,
		const char *fstype,
		const char *device)
{
  struct guestfs_fsck_args args;
  struct fsck_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_fsck") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.fstype = (char *) fstype;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_FSCK,
        (xdrproc_t) xdr_guestfs_fsck_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, fsck_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_fsck");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_FSCK, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return ctx.ret.status;
}

struct zero_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void zero_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct zero_ctx *ctx = (struct zero_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_zero");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_zero");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_zero");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_zero (guestfs_h *g,
		const char *device)
{
  struct guestfs_zero_args args;
  struct zero_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_zero") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_ZERO,
        (xdrproc_t) xdr_guestfs_zero_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, zero_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_zero");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_ZERO, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

struct grub_install_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void grub_install_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct grub_install_ctx *ctx = (struct grub_install_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_grub_install");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_grub_install");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_grub_install");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_grub_install (guestfs_h *g,
		const char *root,
		const char *device)
{
  struct guestfs_grub_install_args args;
  struct grub_install_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_grub_install") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.root = (char *) root;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GRUB_INSTALL,
        (xdrproc_t) xdr_guestfs_grub_install_args, (char *) &args);
  if (serial == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, grub_install_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_grub_install");
    guestfs_set_ready (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GRUB_INSTALL, serial) == -1) {
    guestfs_set_ready (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    guestfs_set_ready (g);
    return -1;
  }

  guestfs_set_ready (g);
  return 0;
}

