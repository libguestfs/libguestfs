=head2 guestfs_add_cdrom

 int guestfs_add_cdrom (guestfs_h *handle,
		const char *filename);

This function adds a virtual CD-ROM disk image to the guest.

This is equivalent to the qemu parameter C<-cdrom filename>.

This function returns 0 on success or -1 on error.

=head2 guestfs_add_drive

 int guestfs_add_drive (guestfs_h *handle,
		const char *filename);

This function adds a virtual machine disk image C<filename> to the
guest.  The first time you call this function, the disk appears as IDE
disk 0 (C</dev/sda>) in the guest, the second time as C</dev/sdb>, and
so on.

You don't necessarily need to be root when using libguestfs.  However
you obviously do need sufficient permissions to access the filename
for whatever operations you want to perform (ie. read access if you
just want to read the image or write access if you want to modify the
image).

This is equivalent to the qemu parameter C<-drive file=filename>.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_close

 int guestfs_aug_close (guestfs_h *handle);

Close the current Augeas handle and free up any resources
used by it.  After calling this, you have to call
C<guestfs_aug_init> again before you can use any other
Augeas functions.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_defnode

 struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *handle,
		const char *name,
		const char *expr,
		const char *val);

Defines a variable C<name> whose value is the result of
evaluating C<expr>.

If C<expr> evaluates to an empty nodeset, a node is created,
equivalent to calling C<guestfs_aug_set> C<expr>, C<value>.
C<name> will be the nodeset containing that single node.

On success this returns a pair containing the
number of nodes in the nodeset, and a boolean flag
if a node was created.

This function returns a C<struct guestfs_int_bool *>,
or NULL if there was an error.
I<The caller must call C<guestfs_free_int_bool> after use>.

=head2 guestfs_aug_defvar

 int guestfs_aug_defvar (guestfs_h *handle,
		const char *name,
		const char *expr);

Defines an Augeas variable C<name> whose value is the result
of evaluating C<expr>.  If C<expr> is NULL, then C<name> is
undefined.

On success this returns the number of nodes in C<expr>, or
C<0> if C<expr> evaluates to something which is not a nodeset.

On error this function returns -1.

=head2 guestfs_aug_get

 char *guestfs_aug_get (guestfs_h *handle,
		const char *path);

Look up the value associated with C<path>.  If C<path>
matches exactly one node, the C<value> is returned.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_aug_init

 int guestfs_aug_init (guestfs_h *handle,
		const char *root,
		int flags);

Create a new Augeas handle for editing configuration files.
If there was any previous Augeas handle associated with this
guestfs session, then it is closed.

You must call this before using any other C<guestfs_aug_*>
commands.

C<root> is the filesystem root.  C<root> must not be NULL,
use C</> instead.

The flags are the same as the flags defined in
E<lt>augeas.hE<gt>, the logical I<or> of the following
integers:

=over 4

=item C<AUG_SAVE_BACKUP> = 1

Keep the original file with a C<.augsave> extension.

=item C<AUG_SAVE_NEWFILE> = 2

Save changes into a file with extension C<.augnew>, and
do not overwrite original.  Overrides C<AUG_SAVE_BACKUP>.

=item C<AUG_TYPE_CHECK> = 4

Typecheck lenses (can be expensive).

=item C<AUG_NO_STDINC> = 8

Do not use standard load path for modules.

=item C<AUG_SAVE_NOOP> = 16

Make save a no-op, just record what would have been changed.

=item C<AUG_NO_LOAD> = 32

Do not load the tree in C<guestfs_aug_init>.

=back

To close the handle, you can call C<guestfs_aug_close>.

To find out more about Augeas, see L<http://augeas.net/>.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_insert

 int guestfs_aug_insert (guestfs_h *handle,
		const char *path,
		const char *label,
		int before);

Create a new sibling C<label> for C<path>, inserting it into
the tree before or after C<path> (depending on the boolean
flag C<before>).

C<path> must match exactly one existing node in the tree, and
C<label> must be a label, ie. not contain C</>, C<*> or end
with a bracketed index C<[N]>.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_load

 int guestfs_aug_load (guestfs_h *handle);

Load files into the tree.

See C<aug_load> in the Augeas documentation for the full gory
details.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_ls

 char **guestfs_aug_ls (guestfs_h *handle,
		const char *path);

This is just a shortcut for listing C<guestfs_aug_match>
C<path/*> and sorting the resulting nodes into alphabetical order.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_aug_match

 char **guestfs_aug_match (guestfs_h *handle,
		const char *path);

Returns a list of paths which match the path expression C<path>.
The returned paths are sufficiently qualified so that they match
exactly one node in the current tree.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_aug_mv

 int guestfs_aug_mv (guestfs_h *handle,
		const char *src,
		const char *dest);

Move the node C<src> to C<dest>.  C<src> must match exactly
one node.  C<dest> is overwritten if it exists.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_rm

 int guestfs_aug_rm (guestfs_h *handle,
		const char *path);

Remove C<path> and all of its children.

On success this returns the number of entries which were removed.

On error this function returns -1.

=head2 guestfs_aug_save

 int guestfs_aug_save (guestfs_h *handle);

This writes all pending changes to disk.

The flags which were passed to C<guestfs_aug_init> affect exactly
how files are saved.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_set

 int guestfs_aug_set (guestfs_h *handle,
		const char *path,
		const char *val);

Set the value associated with C<path> to C<value>.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_flushbufs

 int guestfs_blockdev_flushbufs (guestfs_h *handle,
		const char *device);

This tells the kernel to flush internal buffers associated
with C<device>.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_getbsz

 int guestfs_blockdev_getbsz (guestfs_h *handle,
		const char *device);

This returns the block size of a device.

(Note this is different from both I<size in blocks> and
I<filesystem block size>).

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_getro

 int guestfs_blockdev_getro (guestfs_h *handle,
		const char *device);

Returns a boolean indicating if the block device is read-only
(true if read-only, false if not).

This uses the L<blockdev(8)> command.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_blockdev_getsize64

 int64_t guestfs_blockdev_getsize64 (guestfs_h *handle,
		const char *device);

This returns the size of the device in bytes.

See also C<guestfs_blockdev_getsz>.

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_getss

 int guestfs_blockdev_getss (guestfs_h *handle,
		const char *device);

This returns the size of sectors on a block device.
Usually 512, but can be larger for modern devices.

(Note, this is not the size in sectors, use C<guestfs_blockdev_getsz>
for that).

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_getsz

 int64_t guestfs_blockdev_getsz (guestfs_h *handle,
		const char *device);

This returns the size of the device in units of 512-byte sectors
(even if the sectorsize isn't 512 bytes ... weird).

See also C<guestfs_blockdev_getss> for the real sector size of
the device, and C<guestfs_blockdev_getsize64> for the more
useful I<size in bytes>.

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_rereadpt

 int guestfs_blockdev_rereadpt (guestfs_h *handle,
		const char *device);

Reread the partition table on C<device>.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_setbsz

 int guestfs_blockdev_setbsz (guestfs_h *handle,
		const char *device,
		int blocksize);

This sets the block size of a device.

(Note this is different from both I<size in blocks> and
I<filesystem block size>).

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_setro

 int guestfs_blockdev_setro (guestfs_h *handle,
		const char *device);

Sets the block device named C<device> to read-only.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_setrw

 int guestfs_blockdev_setrw (guestfs_h *handle,
		const char *device);

Sets the block device named C<device> to read-write.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_cat

 char *guestfs_cat (guestfs_h *handle,
		const char *path);

Return the contents of the file named C<path>.

Note that this function cannot correctly handle binary files
(specifically, files containing C<\0> character which is treated
as end of string).  For those you need to use the C<guestfs_download>
function which has a more complex interface.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

Because of the message protocol, there is a transfer limit 
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_chmod

 int guestfs_chmod (guestfs_h *handle,
		int mode,
		const char *path);

Change the mode (permissions) of C<path> to C<mode>.  Only
numeric modes are supported.

This function returns 0 on success or -1 on error.

=head2 guestfs_chown

 int guestfs_chown (guestfs_h *handle,
		int owner,
		int group,
		const char *path);

Change the file owner to C<owner> and group to C<group>.

Only numeric uid and gid are supported.  If you want to use
names, you will need to locate and parse the password file
yourself (Augeas support makes this relatively easy).

This function returns 0 on success or -1 on error.

=head2 guestfs_command

 char *guestfs_command (guestfs_h *handle,
		char * const* const arguments);

This call runs a command from the guest filesystem.  The
filesystem must be mounted, and must contain a compatible
operating system (ie. something Linux, with the same
or compatible processor architecture).

The single parameter is an argv-style list of arguments.
The first element is the name of the program to run.
Subsequent elements are parameters.  The list must be
non-empty (ie. must contain a program name).

The C<$PATH> environment variable will contain at least
C</usr/bin> and C</bin>.  If you require a program from
another location, you should provide the full path in the
first parameter.

Shared libraries and data files required by the program
must be available on filesystems which are mounted in the
correct places.  It is the caller's responsibility to ensure
all filesystems that are needed are mounted at the right
locations.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_command_lines

 char **guestfs_command_lines (guestfs_h *handle,
		char * const* const arguments);

This is the same as C<guestfs_command>, but splits the
result into a list of lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_config

 int guestfs_config (guestfs_h *handle,
		const char *qemuparam,
		const char *qemuvalue);

This can be used to add arbitrary qemu command line parameters
of the form C<-param value>.  Actually it's not quite arbitrary - we
prevent you from setting some parameters which would interfere with
parameters that we use.

The first character of C<param> string must be a C<-> (dash).

C<value> can be NULL.

This function returns 0 on success or -1 on error.

=head2 guestfs_download

 int guestfs_download (guestfs_h *handle,
		const char *remotefilename,
		const char *filename);

Download file C<remotefilename> and save it as C<filename>
on the local machine.

C<filename> can also be a named pipe.

See also C<guestfs_upload>, C<guestfs_cat>.

This function returns 0 on success or -1 on error.

=head2 guestfs_exists

 int guestfs_exists (guestfs_h *handle,
		const char *path);

This returns C<true> if and only if there is a file, directory
(or anything) with the given C<path> name.

See also C<guestfs_is_file>, C<guestfs_is_dir>, C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_file

 char *guestfs_file (guestfs_h *handle,
		const char *path);

This call uses the standard L<file(1)> command to determine
the type or contents of the file.  This also works on devices,
for example to find out whether a partition contains a filesystem.

The exact command which runs is C<file -bsL path>.  Note in
particular that the filename is not prepended to the output
(the C<-b> option).

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_get_autosync

 int guestfs_get_autosync (guestfs_h *handle);

Get the autosync flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_get_path

 const char *guestfs_get_path (guestfs_h *handle);

Return the current search path.

This is always non-NULL.  If it wasn't set already, then this will
return the default path.

This function returns a string, or NULL on error.
The string is owned by the guest handle and must I<not> be freed.

=head2 guestfs_get_state

 int guestfs_get_state (guestfs_h *handle);

This returns the current state as an opaque integer.  This is
only useful for printing debug and internal error messages.

For more information on states, see L<guestfs(3)>.

On error this function returns -1.

=head2 guestfs_get_verbose

 int guestfs_get_verbose (guestfs_h *handle);

This returns the verbose messages flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_busy

 int guestfs_is_busy (guestfs_h *handle);

This returns true iff this handle is busy processing a command
(in the C<BUSY> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_config

 int guestfs_is_config (guestfs_h *handle);

This returns true iff this handle is being configured
(in the C<CONFIG> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_dir

 int guestfs_is_dir (guestfs_h *handle,
		const char *path);

This returns C<true> if and only if there is a directory
with the given C<path> name.  Note that it returns false for
other objects like files.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_file

 int guestfs_is_file (guestfs_h *handle,
		const char *path);

This returns C<true> if and only if there is a file
with the given C<path> name.  Note that it returns false for
other objects like directories.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_launching

 int guestfs_is_launching (guestfs_h *handle);

This returns true iff this handle is launching the subprocess
(in the C<LAUNCHING> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_ready

 int guestfs_is_ready (guestfs_h *handle);

This returns true iff this handle is ready to accept commands
(in the C<READY> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_kill_subprocess

 int guestfs_kill_subprocess (guestfs_h *handle);

This kills the qemu subprocess.  You should never need to call this.

This function returns 0 on success or -1 on error.

=head2 guestfs_launch

 int guestfs_launch (guestfs_h *handle);

Internally libguestfs is implemented by running a virtual machine
using L<qemu(1)>.

You should call this after configuring the handle
(eg. adding drives) but before performing any actions.

This function returns 0 on success or -1 on error.

=head2 guestfs_list_devices

 char **guestfs_list_devices (guestfs_h *handle);

List all the block devices.

The full block device names are returned, eg. C</dev/sda>

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_list_partitions

 char **guestfs_list_partitions (guestfs_h *handle);

List all the partitions detected on all block devices.

The full partition device names are returned, eg. C</dev/sda1>

This does not return logical volumes.  For that you will need to
call C<guestfs_lvs>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_ll

 char *guestfs_ll (guestfs_h *handle,
		const char *directory);

List the files in C<directory> (relative to the root directory,
there is no cwd) in the format of 'ls -la'.

This command is mostly useful for interactive sessions.  It
is I<not> intended that you try to parse the output string.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_ls

 char **guestfs_ls (guestfs_h *handle,
		const char *directory);

List the files in C<directory> (relative to the root directory,
there is no cwd).  The '.' and '..' entries are not returned, but
hidden files are shown.

This command is mostly useful for interactive sessions.  Programs
should probably use C<guestfs_readdir> instead.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_lstat

 struct guestfs_stat *guestfs_lstat (guestfs_h *handle,
		const char *path);

Returns file information for the given C<path>.

This is the same as C<guestfs_stat> except that if C<path>
is a symbolic link, then the link is stat-ed, not the file it
refers to.

This is the same as the C<lstat(2)> system call.

This function returns a C<struct guestfs_stat *>
(see L<stat(2)> and E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<free> after use>.

=head2 guestfs_lvcreate

 int guestfs_lvcreate (guestfs_h *handle,
		const char *logvol,
		const char *volgroup,
		int mbytes);

This creates an LVM volume group called C<logvol>
on the volume group C<volgroup>, with C<size> megabytes.

This function returns 0 on success or -1 on error.

=head2 guestfs_lvm_remove_all

 int guestfs_lvm_remove_all (guestfs_h *handle);

This command removes all LVM logical volumes, volume groups
and physical volumes.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_lvs

 char **guestfs_lvs (guestfs_h *handle);

List all the logical volumes detected.  This is the equivalent
of the L<lvs(8)> command.

This returns a list of the logical volume device names
(eg. C</dev/VolGroup00/LogVol00>).

See also C<guestfs_lvs_full>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_lvs_full

 struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *handle);

List all the logical volumes detected.  This is the equivalent
of the L<lvs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_lv_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_lvm_lv_list> after use>.

=head2 guestfs_mkdir

 int guestfs_mkdir (guestfs_h *handle,
		const char *path);

Create a directory named C<path>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkdir_p

 int guestfs_mkdir_p (guestfs_h *handle,
		const char *path);

Create a directory named C<path>, creating any parent directories
as necessary.  This is like the C<mkdir -p> shell command.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkfs

 int guestfs_mkfs (guestfs_h *handle,
		const char *fstype,
		const char *device);

This creates a filesystem on C<device> (usually a partition
of LVM logical volume).  The filesystem type is C<fstype>, for
example C<ext3>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mount

 int guestfs_mount (guestfs_h *handle,
		const char *device,
		const char *mountpoint);

Mount a guest disk at a position in the filesystem.  Block devices
are named C</dev/sda>, C</dev/sdb> and so on, as they were added to
the guest.  If those block devices contain partitions, they will have
the usual names (eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style
names can be used.

The rules are the same as for L<mount(2)>:  A filesystem must
first be mounted on C</> before others can be mounted.  Other
filesystems can only be mounted on directories which already
exist.

The mounted filesystem is writable, if we have sufficient permissions
on the underlying device.

The filesystem options C<sync> and C<noatime> are set with this
call, in order to improve reliability.

This function returns 0 on success or -1 on error.

=head2 guestfs_mounts

 char **guestfs_mounts (guestfs_h *handle);

This returns the list of currently mounted filesystems.  It returns
the list of devices (eg. C</dev/sda1>, C</dev/VG/LV>).

Some internal mounts are not shown.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_pvcreate

 int guestfs_pvcreate (guestfs_h *handle,
		const char *device);

This creates an LVM physical volume on the named C<device>,
where C<device> should usually be a partition name such
as C</dev/sda1>.

This function returns 0 on success or -1 on error.

=head2 guestfs_pvs

 char **guestfs_pvs (guestfs_h *handle);

List all the physical volumes detected.  This is the equivalent
of the L<pvs(8)> command.

This returns a list of just the device names that contain
PVs (eg. C</dev/sda2>).

See also C<guestfs_pvs_full>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_pvs_full

 struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *handle);

List all the physical volumes detected.  This is the equivalent
of the L<pvs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_pv_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_lvm_pv_list> after use>.

=head2 guestfs_read_lines

 char **guestfs_read_lines (guestfs_h *handle,
		const char *path);

Return the contents of the file named C<path>.

The file contents are returned as a list of lines.  Trailing
C<LF> and C<CRLF> character sequences are I<not> returned.

Note that this function cannot correctly handle binary files
(specifically, files containing C<\0> character which is treated
as end of line).  For those you need to use the C<guestfs_read_file>
function which has a more complex interface.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_rm

 int guestfs_rm (guestfs_h *handle,
		const char *path);

Remove the single file C<path>.

This function returns 0 on success or -1 on error.

=head2 guestfs_rm_rf

 int guestfs_rm_rf (guestfs_h *handle,
		const char *path);

Remove the file or directory C<path>, recursively removing the
contents if its a directory.  This is like the C<rm -rf> shell
command.

This function returns 0 on success or -1 on error.

=head2 guestfs_rmdir

 int guestfs_rmdir (guestfs_h *handle,
		const char *path);

Remove the single directory C<path>.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_autosync

 int guestfs_set_autosync (guestfs_h *handle,
		int autosync);

If C<autosync> is true, this enables autosync.  Libguestfs will make a
best effort attempt to run C<guestfs_sync> when the handle is closed
(also if the program exits without closing handles).

This function returns 0 on success or -1 on error.

=head2 guestfs_set_path

 int guestfs_set_path (guestfs_h *handle,
		const char *path);

Set the path that libguestfs searches for kernel and initrd.img.

The default is C<$libdir/guestfs> unless overridden by setting
C<LIBGUESTFS_PATH> environment variable.

The string C<path> is stashed in the libguestfs handle, so the caller
must make sure it remains valid for the lifetime of the handle.

Setting C<path> to C<NULL> restores the default path.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_verbose

 int guestfs_set_verbose (guestfs_h *handle,
		int verbose);

If C<verbose> is true, this turns on verbose messages (to C<stderr>).

Verbose messages are disabled unless the environment variable
C<LIBGUESTFS_DEBUG> is defined and set to C<1>.

This function returns 0 on success or -1 on error.

=head2 guestfs_sfdisk

 int guestfs_sfdisk (guestfs_h *handle,
		const char *device,
		int cyls,
		int heads,
		int sectors,
		char * const* const lines);

This is a direct interface to the L<sfdisk(8)> program for creating
partitions on block devices.

C<device> should be a block device, for example C</dev/sda>.

C<cyls>, C<heads> and C<sectors> are the number of cylinders, heads
and sectors on the device, which are passed directly to sfdisk as
the I<-C>, I<-H> and I<-S> parameters.  If you pass C<0> for any
of these, then the corresponding parameter is omitted.  Usually for
'large' disks, you can just pass C<0> for these, but for small
(floppy-sized) disks, sfdisk (or rather, the kernel) cannot work
out the right geometry and you will need to tell it.

C<lines> is a list of lines that we feed to C<sfdisk>.  For more
information refer to the L<sfdisk(8)> manpage.

To create a single partition occupying the whole disk, you would
pass C<lines> as a single element list, when the single element being
the string C<,> (comma).

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_stat

 struct guestfs_stat *guestfs_stat (guestfs_h *handle,
		const char *path);

Returns file information for the given C<path>.

This is the same as the C<stat(2)> system call.

This function returns a C<struct guestfs_stat *>
(see L<stat(2)> and E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<free> after use>.

=head2 guestfs_statvfs

 struct guestfs_statvfs *guestfs_statvfs (guestfs_h *handle,
		const char *path);

Returns file system statistics for any mounted file system.
C<path> should be a file or directory in the mounted file system
(typically it is the mount point itself, but it doesn't need to be).

This is the same as the C<statvfs(2)> system call.

This function returns a C<struct guestfs_statvfs *>
(see L<statvfs(2)> and E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<free> after use>.

=head2 guestfs_sync

 int guestfs_sync (guestfs_h *handle);

This syncs the disk, so that any writes are flushed through to the
underlying disk image.

You should always call this if you have modified a disk image, before
closing the handle.

This function returns 0 on success or -1 on error.

=head2 guestfs_touch

 int guestfs_touch (guestfs_h *handle,
		const char *path);

Touch acts like the L<touch(1)> command.  It can be used to
update the timestamps on a file, or, if the file does not exist,
to create a new zero-length file.

This function returns 0 on success or -1 on error.

=head2 guestfs_tune2fs_l

 char **guestfs_tune2fs_l (guestfs_h *handle,
		const char *device);

This returns the contents of the ext2 or ext3 filesystem superblock
on C<device>.

It is the same as running C<tune2fs -l device>.  See L<tune2fs(8)>
manpage for more details.  The list of fields returned isn't
clearly defined, and depends on both the version of C<tune2fs>
that libguestfs was built against, and the filesystem itself.

This function returns a NULL-terminated array of
strings, or NULL if there was an error.
The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.
I<The caller must free the strings and the array after use>.

=head2 guestfs_umount

 int guestfs_umount (guestfs_h *handle,
		const char *pathordevice);

This unmounts the given filesystem.  The filesystem may be
specified either by its mountpoint (path) or the device which
contains the filesystem.

This function returns 0 on success or -1 on error.

=head2 guestfs_umount_all

 int guestfs_umount_all (guestfs_h *handle);

This unmounts all mounted filesystems.

Some internal mounts are not unmounted by this call.

This function returns 0 on success or -1 on error.

=head2 guestfs_upload

 int guestfs_upload (guestfs_h *handle,
		const char *filename,
		const char *remotefilename);

Upload local file C<filename> to C<remotefilename> on the
filesystem.

C<filename> can also be a named pipe.

See also C<guestfs_download>.

This function returns 0 on success or -1 on error.

=head2 guestfs_vgcreate

 int guestfs_vgcreate (guestfs_h *handle,
		const char *volgroup,
		char * const* const physvols);

This creates an LVM volume group called C<volgroup>
from the non-empty list of physical volumes C<physvols>.

This function returns 0 on success or -1 on error.

=head2 guestfs_vgs

 char **guestfs_vgs (guestfs_h *handle);

List all the volumes groups detected.  This is the equivalent
of the L<vgs(8)> command.

This returns a list of just the volume group names that were
detected (eg. C<VolGroup00>).

See also C<guestfs_vgs_full>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_vgs_full

 struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *handle);

List all the volumes groups detected.  This is the equivalent
of the L<vgs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_vg_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_lvm_vg_list> after use>.

=head2 guestfs_wait_ready

 int guestfs_wait_ready (guestfs_h *handle);

Internally libguestfs is implemented by running a virtual machine
using L<qemu(1)>.

You should call this after C<guestfs_launch> to wait for the launch
to complete.

This function returns 0 on success or -1 on error.

=head2 guestfs_write_file

 int guestfs_write_file (guestfs_h *handle,
		const char *path,
		const char *content,
		int size);

This call creates a file called C<path>.  The contents of the
file is the string C<content> (which can contain any 8 bit data),
with length C<size>.

As a special case, if C<size> is C<0>
then the length is calculated using C<strlen> (so in this case
the content cannot contain embedded ASCII NULs).

This function returns 0 on success or -1 on error.

Because of the message protocol, there is a transfer limit 
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

