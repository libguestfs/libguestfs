/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

package com.redhat.et.libguestfs;

import java.util.HashMap;
import com.redhat.et.libguestfs.LibGuestFSException;
import com.redhat.et.libguestfs.PV;
import com.redhat.et.libguestfs.VG;
import com.redhat.et.libguestfs.LV;
import com.redhat.et.libguestfs.Stat;
import com.redhat.et.libguestfs.StatVFS;
import com.redhat.et.libguestfs.IntBool;

/**
 * The GuestFS object is a libguestfs handle.
 *
 * @author rjones
 */
public class GuestFS {
  // Load the native code.
  static {
    System.loadLibrary ("guestfs_jni");
  }

  /**
   * The native guestfs_h pointer.
   */
  long g;

  /**
   * Create a libguestfs handle.
   *
   * @throws LibGuestFSException
   */
  public GuestFS () throws LibGuestFSException
  {
    g = _create ();
  }
  private native long _create () throws LibGuestFSException;

  /**
   * Close a libguestfs handle.
   *
   * You can also leave handles to be collected by the garbage
   * collector, but this method ensures that the resources used
   * by the handle are freed up immediately.  If you call any
   * other methods after closing the handle, you will get an
   * exception.
   *
   * @throws LibGuestFSException
   */
  public void close () throws LibGuestFSException
  {
    if (g != 0)
      _close (g);
    g = 0;
  }
  private native void _close (long g) throws LibGuestFSException;

  public void finalize () throws LibGuestFSException
  {
    close ();
  }

public void test0 (String str, String optstr, String[] strlist, boolean b, int integer, String filein, String fileout)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0: handle is closed");
    _test0 (g, str, optstr, strlist, b, integer, filein, fileout);
  }
  private native void _test0 (long g, String str, String optstr, String[] strlist, boolean b, int integer, String filein, String fileout)
    throws LibGuestFSException;

public int test0rint (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rint: handle is closed");
    return _test0rint (g, val);
  }
  private native int _test0rint (long g, String val)
    throws LibGuestFSException;

public int test0rinterr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rinterr: handle is closed");
    return _test0rinterr (g);
  }
  private native int _test0rinterr (long g)
    throws LibGuestFSException;

public long test0rint64 (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rint64: handle is closed");
    return _test0rint64 (g, val);
  }
  private native long _test0rint64 (long g, String val)
    throws LibGuestFSException;

public long test0rint64err ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rint64err: handle is closed");
    return _test0rint64err (g);
  }
  private native long _test0rint64err (long g)
    throws LibGuestFSException;

public boolean test0rbool (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rbool: handle is closed");
    return _test0rbool (g, val);
  }
  private native boolean _test0rbool (long g, String val)
    throws LibGuestFSException;

public boolean test0rboolerr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rboolerr: handle is closed");
    return _test0rboolerr (g);
  }
  private native boolean _test0rboolerr (long g)
    throws LibGuestFSException;

public String test0rconststring (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rconststring: handle is closed");
    return _test0rconststring (g, val);
  }
  private native String _test0rconststring (long g, String val)
    throws LibGuestFSException;

public String test0rconststringerr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rconststringerr: handle is closed");
    return _test0rconststringerr (g);
  }
  private native String _test0rconststringerr (long g)
    throws LibGuestFSException;

public String test0rstring (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstring: handle is closed");
    return _test0rstring (g, val);
  }
  private native String _test0rstring (long g, String val)
    throws LibGuestFSException;

public String test0rstringerr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstringerr: handle is closed");
    return _test0rstringerr (g);
  }
  private native String _test0rstringerr (long g)
    throws LibGuestFSException;

public String[] test0rstringlist (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstringlist: handle is closed");
    return _test0rstringlist (g, val);
  }
  private native String[] _test0rstringlist (long g, String val)
    throws LibGuestFSException;

public String[] test0rstringlisterr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstringlisterr: handle is closed");
    return _test0rstringlisterr (g);
  }
  private native String[] _test0rstringlisterr (long g)
    throws LibGuestFSException;

public IntBool test0rintbool (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rintbool: handle is closed");
    return _test0rintbool (g, val);
  }
  private native IntBool _test0rintbool (long g, String val)
    throws LibGuestFSException;

public IntBool test0rintboolerr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rintboolerr: handle is closed");
    return _test0rintboolerr (g);
  }
  private native IntBool _test0rintboolerr (long g)
    throws LibGuestFSException;

public PV[] test0rpvlist (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rpvlist: handle is closed");
    return _test0rpvlist (g, val);
  }
  private native PV[] _test0rpvlist (long g, String val)
    throws LibGuestFSException;

public PV[] test0rpvlisterr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rpvlisterr: handle is closed");
    return _test0rpvlisterr (g);
  }
  private native PV[] _test0rpvlisterr (long g)
    throws LibGuestFSException;

public VG[] test0rvglist (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rvglist: handle is closed");
    return _test0rvglist (g, val);
  }
  private native VG[] _test0rvglist (long g, String val)
    throws LibGuestFSException;

public VG[] test0rvglisterr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rvglisterr: handle is closed");
    return _test0rvglisterr (g);
  }
  private native VG[] _test0rvglisterr (long g)
    throws LibGuestFSException;

public LV[] test0rlvlist (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rlvlist: handle is closed");
    return _test0rlvlist (g, val);
  }
  private native LV[] _test0rlvlist (long g, String val)
    throws LibGuestFSException;

public LV[] test0rlvlisterr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rlvlisterr: handle is closed");
    return _test0rlvlisterr (g);
  }
  private native LV[] _test0rlvlisterr (long g)
    throws LibGuestFSException;

public Stat test0rstat (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstat: handle is closed");
    return _test0rstat (g, val);
  }
  private native Stat _test0rstat (long g, String val)
    throws LibGuestFSException;

public Stat test0rstaterr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstaterr: handle is closed");
    return _test0rstaterr (g);
  }
  private native Stat _test0rstaterr (long g)
    throws LibGuestFSException;

public StatVFS test0rstatvfs (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstatvfs: handle is closed");
    return _test0rstatvfs (g, val);
  }
  private native StatVFS _test0rstatvfs (long g, String val)
    throws LibGuestFSException;

public StatVFS test0rstatvfserr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rstatvfserr: handle is closed");
    return _test0rstatvfserr (g);
  }
  private native StatVFS _test0rstatvfserr (long g)
    throws LibGuestFSException;

public HashMap<String,String> test0rhashtable (String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rhashtable: handle is closed");
    return _test0rhashtable (g, val);
  }
  private native HashMap<String,String> _test0rhashtable (long g, String val)
    throws LibGuestFSException;

public HashMap<String,String> test0rhashtableerr ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("test0rhashtableerr: handle is closed");
    return _test0rhashtableerr (g);
  }
  private native HashMap<String,String> _test0rhashtableerr (long g)
    throws LibGuestFSException;

  /**
   * launch the qemu subprocess
   * <p>
   * Internally libguestfs is implemented by running a
   * virtual machine using qemu(1).
   * <p>
   * You should call this after configuring the handle (eg.
   * adding drives) but before performing any actions.
   * <p>
   * @throws LibGuestFSException
   */
  public void launch ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("launch: handle is closed");
    _launch (g);
  }
  private native void _launch (long g)
    throws LibGuestFSException;

  /**
   * wait until the qemu subprocess launches
   * <p>
   * Internally libguestfs is implemented by running a
   * virtual machine using qemu(1).
   * <p>
   * You should call this after "g.launch" to wait for the
   * launch to complete.
   * <p>
   * @throws LibGuestFSException
   */
  public void wait_ready ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("wait_ready: handle is closed");
    _wait_ready (g);
  }
  private native void _wait_ready (long g)
    throws LibGuestFSException;

  /**
   * kill the qemu subprocess
   * <p>
   * This kills the qemu subprocess. You should never need to
   * call this.
   * <p>
   * @throws LibGuestFSException
   */
  public void kill_subprocess ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("kill_subprocess: handle is closed");
    _kill_subprocess (g);
  }
  private native void _kill_subprocess (long g)
    throws LibGuestFSException;

  /**
   * add an image to examine or modify
   * <p>
   * This function adds a virtual machine disk image
   * "filename" to the guest. The first time you call this
   * function, the disk appears as IDE disk 0 ("/dev/sda") in
   * the guest, the second time as "/dev/sdb", and so on.
   * <p>
   * You don't necessarily need to be root when using
   * libguestfs. However you obviously do need sufficient
   * permissions to access the filename for whatever
   * operations you want to perform (ie. read access if you
   * just want to read the image or write access if you want
   * to modify the image).
   * <p>
   * This is equivalent to the qemu parameter "-drive
   * file=filename,cache=off".
   * <p>
   * Note that this call checks for the existence of
   * "filename". This stops you from specifying other types
   * of drive which are supported by qemu such as "nbd:" and
   * "http:" URLs. To specify those, use the general
   * "g.config" call instead.
   * <p>
   * @throws LibGuestFSException
   */
  public void add_drive (String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("add_drive: handle is closed");
    _add_drive (g, filename);
  }
  private native void _add_drive (long g, String filename)
    throws LibGuestFSException;

  /**
   * add a CD-ROM disk image to examine
   * <p>
   * This function adds a virtual CD-ROM disk image to the
   * guest.
   * <p>
   * This is equivalent to the qemu parameter "-cdrom
   * filename".
   * <p>
   * Note that this call checks for the existence of
   * "filename". This stops you from specifying other types
   * of drive which are supported by qemu such as "nbd:" and
   * "http:" URLs. To specify those, use the general
   * "g.config" call instead.
   * <p>
   * @throws LibGuestFSException
   */
  public void add_cdrom (String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("add_cdrom: handle is closed");
    _add_cdrom (g, filename);
  }
  private native void _add_cdrom (long g, String filename)
    throws LibGuestFSException;

  /**
   * add a drive in snapshot mode (read-only)
   * <p>
   * This adds a drive in snapshot mode, making it
   * effectively read-only.
   * <p>
   * Note that writes to the device are allowed, and will be
   * seen for the duration of the guestfs handle, but they
   * are written to a temporary file which is discarded as
   * soon as the guestfs handle is closed. We don't currently
   * have any method to enable changes to be committed,
   * although qemu can support this.
   * <p>
   * This is equivalent to the qemu parameter "-drive
   * file=filename,snapshot=on".
   * <p>
   * Note that this call checks for the existence of
   * "filename". This stops you from specifying other types
   * of drive which are supported by qemu such as "nbd:" and
   * "http:" URLs. To specify those, use the general
   * "g.config" call instead.
   * <p>
   * @throws LibGuestFSException
   */
  public void add_drive_ro (String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("add_drive_ro: handle is closed");
    _add_drive_ro (g, filename);
  }
  private native void _add_drive_ro (long g, String filename)
    throws LibGuestFSException;

  /**
   * add qemu parameters
   * <p>
   * This can be used to add arbitrary qemu command line
   * parameters of the form "-param value". Actually it's not
   * quite arbitrary - we prevent you from setting some
   * parameters which would interfere with parameters that we
   * use.
   * <p>
   * The first character of "param" string must be a "-"
   * (dash).
   * <p>
   * "value" can be NULL.
   * <p>
   * @throws LibGuestFSException
   */
  public void config (String qemuparam, String qemuvalue)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("config: handle is closed");
    _config (g, qemuparam, qemuvalue);
  }
  private native void _config (long g, String qemuparam, String qemuvalue)
    throws LibGuestFSException;

  /**
   * set the qemu binary
   * <p>
   * Set the qemu binary that we will use.
   * <p>
   * The default is chosen when the library was compiled by
   * the configure script.
   * <p>
   * You can also override this by setting the
   * "LIBGUESTFS_QEMU" environment variable.
   * <p>
   * Setting "qemu" to "NULL" restores the default qemu
   * binary.
   * <p>
   * @throws LibGuestFSException
   */
  public void set_qemu (String qemu)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_qemu: handle is closed");
    _set_qemu (g, qemu);
  }
  private native void _set_qemu (long g, String qemu)
    throws LibGuestFSException;

  /**
   * get the qemu binary
   * <p>
   * Return the current qemu binary.
   * <p>
   * This is always non-NULL. If it wasn't set already, then
   * this will return the default qemu binary name.
   * <p>
   * @throws LibGuestFSException
   */
  public String get_qemu ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_qemu: handle is closed");
    return _get_qemu (g);
  }
  private native String _get_qemu (long g)
    throws LibGuestFSException;

  /**
   * set the search path
   * <p>
   * Set the path that libguestfs searches for kernel and
   * initrd.img.
   * <p>
   * The default is "$libdir/guestfs" unless overridden by
   * setting "LIBGUESTFS_PATH" environment variable.
   * <p>
   * Setting "path" to "NULL" restores the default path.
   * <p>
   * @throws LibGuestFSException
   */
  public void set_path (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_path: handle is closed");
    _set_path (g, path);
  }
  private native void _set_path (long g, String path)
    throws LibGuestFSException;

  /**
   * get the search path
   * <p>
   * Return the current search path.
   * <p>
   * This is always non-NULL. If it wasn't set already, then
   * this will return the default path.
   * <p>
   * @throws LibGuestFSException
   */
  public String get_path ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_path: handle is closed");
    return _get_path (g);
  }
  private native String _get_path (long g)
    throws LibGuestFSException;

  /**
   * add options to kernel command line
   * <p>
   * This function is used to add additional options to the
   * guest kernel command line.
   * <p>
   * The default is "NULL" unless overridden by setting
   * "LIBGUESTFS_APPEND" environment variable.
   * <p>
   * Setting "append" to "NULL" means *no* additional options
   * are passed (libguestfs always adds a few of its own).
   * <p>
   * @throws LibGuestFSException
   */
  public void set_append (String append)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_append: handle is closed");
    _set_append (g, append);
  }
  private native void _set_append (long g, String append)
    throws LibGuestFSException;

  /**
   * get the additional kernel options
   * <p>
   * Return the additional kernel options which are added to
   * the guest kernel command line.
   * <p>
   * If "NULL" then no options are added.
   * <p>
   * @throws LibGuestFSException
   */
  public String get_append ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_append: handle is closed");
    return _get_append (g);
  }
  private native String _get_append (long g)
    throws LibGuestFSException;

  /**
   * set autosync mode
   * <p>
   * If "autosync" is true, this enables autosync. Libguestfs
   * will make a best effort attempt to run "g.umount_all"
   * followed by "g.sync" when the handle is closed (also if
   * the program exits without closing handles).
   * <p>
   * This is disabled by default (except in guestfish where
   * it is enabled by default).
   * <p>
   * @throws LibGuestFSException
   */
  public void set_autosync (boolean autosync)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_autosync: handle is closed");
    _set_autosync (g, autosync);
  }
  private native void _set_autosync (long g, boolean autosync)
    throws LibGuestFSException;

  /**
   * get autosync mode
   * <p>
   * Get the autosync flag.
   * <p>
   * @throws LibGuestFSException
   */
  public boolean get_autosync ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_autosync: handle is closed");
    return _get_autosync (g);
  }
  private native boolean _get_autosync (long g)
    throws LibGuestFSException;

  /**
   * set verbose mode
   * <p>
   * If "verbose" is true, this turns on verbose messages (to
   * "stderr").
   * <p>
   * Verbose messages are disabled unless the environment
   * variable "LIBGUESTFS_DEBUG" is defined and set to 1.
   * <p>
   * @throws LibGuestFSException
   */
  public void set_verbose (boolean verbose)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_verbose: handle is closed");
    _set_verbose (g, verbose);
  }
  private native void _set_verbose (long g, boolean verbose)
    throws LibGuestFSException;

  /**
   * get verbose mode
   * <p>
   * This returns the verbose messages flag.
   * <p>
   * @throws LibGuestFSException
   */
  public boolean get_verbose ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_verbose: handle is closed");
    return _get_verbose (g);
  }
  private native boolean _get_verbose (long g)
    throws LibGuestFSException;

  /**
   * is ready to accept commands
   * <p>
   * This returns true iff this handle is ready to accept
   * commands (in the "READY" state).
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public boolean is_ready ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_ready: handle is closed");
    return _is_ready (g);
  }
  private native boolean _is_ready (long g)
    throws LibGuestFSException;

  /**
   * is in configuration state
   * <p>
   * This returns true iff this handle is being configured
   * (in the "CONFIG" state).
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public boolean is_config ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_config: handle is closed");
    return _is_config (g);
  }
  private native boolean _is_config (long g)
    throws LibGuestFSException;

  /**
   * is launching subprocess
   * <p>
   * This returns true iff this handle is launching the
   * subprocess (in the "LAUNCHING" state).
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public boolean is_launching ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_launching: handle is closed");
    return _is_launching (g);
  }
  private native boolean _is_launching (long g)
    throws LibGuestFSException;

  /**
   * is busy processing a command
   * <p>
   * This returns true iff this handle is busy processing a
   * command (in the "BUSY" state).
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public boolean is_busy ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_busy: handle is closed");
    return _is_busy (g);
  }
  private native boolean _is_busy (long g)
    throws LibGuestFSException;

  /**
   * get the current state
   * <p>
   * This returns the current state as an opaque integer.
   * This is only useful for printing debug and internal
   * error messages.
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public int get_state ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_state: handle is closed");
    return _get_state (g);
  }
  private native int _get_state (long g)
    throws LibGuestFSException;

  /**
   * set state to busy
   * <p>
   * This sets the state to "BUSY". This is only used when
   * implementing actions using the low-level API.
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public void set_busy ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_busy: handle is closed");
    _set_busy (g);
  }
  private native void _set_busy (long g)
    throws LibGuestFSException;

  /**
   * set state to ready
   * <p>
   * This sets the state to "READY". This is only used when
   * implementing actions using the low-level API.
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public void set_ready ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_ready: handle is closed");
    _set_ready (g);
  }
  private native void _set_ready (long g)
    throws LibGuestFSException;

  /**
   * leave the busy state
   * <p>
   * This sets the state to "READY", or if in "CONFIG" then
   * it leaves the state as is. This is only used when
   * implementing actions using the low-level API.
   * <p>
   * For more information on states, see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public void end_busy ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("end_busy: handle is closed");
    _end_busy (g);
  }
  private native void _end_busy (long g)
    throws LibGuestFSException;

  /**
   * set memory allocated to the qemu subprocess
   * <p>
   * This sets the memory size in megabytes allocated to the
   * qemu subprocess. This only has any effect if called
   * before "g.launch".
   * <p>
   * You can also change this by setting the environment
   * variable "LIBGUESTFS_MEMSIZE" before the handle is
   * created.
   * <p>
   * For more information on the architecture of libguestfs,
   * see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public void set_memsize (int memsize)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_memsize: handle is closed");
    _set_memsize (g, memsize);
  }
  private native void _set_memsize (long g, int memsize)
    throws LibGuestFSException;

  /**
   * get memory allocated to the qemu subprocess
   * <p>
   * This gets the memory size in megabytes allocated to the
   * qemu subprocess.
   * <p>
   * If "g.set_memsize" was not called on this handle, and if
   * "LIBGUESTFS_MEMSIZE" was not set, then this returns the
   * compiled-in default value for memsize.
   * <p>
   * For more information on the architecture of libguestfs,
   * see guestfs(3).
   * <p>
   * @throws LibGuestFSException
   */
  public int get_memsize ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_memsize: handle is closed");
    return _get_memsize (g);
  }
  private native int _get_memsize (long g)
    throws LibGuestFSException;

  /**
   * mount a guest disk at a position in the filesystem
   * <p>
   * Mount a guest disk at a position in the filesystem.
   * Block devices are named "/dev/sda", "/dev/sdb" and so
   * on, as they were added to the guest. If those block
   * devices contain partitions, they will have the usual
   * names (eg. "/dev/sda1"). Also LVM "/dev/VG/LV"-style
   * names can be used.
   * <p>
   * The rules are the same as for mount(2): A filesystem
   * must first be mounted on "/" before others can be
   * mounted. Other filesystems can only be mounted on
   * directories which already exist.
   * <p>
   * The mounted filesystem is writable, if we have
   * sufficient permissions on the underlying device.
   * <p>
   * The filesystem options "sync" and "noatime" are set with
   * this call, in order to improve reliability.
   * <p>
   * @throws LibGuestFSException
   */
  public void mount (String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount: handle is closed");
    _mount (g, device, mountpoint);
  }
  private native void _mount (long g, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * sync disks, writes are flushed through to the disk image
   * <p>
   * This syncs the disk, so that any writes are flushed
   * through to the underlying disk image.
   * <p>
   * You should always call this if you have modified a disk
   * image, before closing the handle.
   * <p>
   * @throws LibGuestFSException
   */
  public void sync ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sync: handle is closed");
    _sync (g);
  }
  private native void _sync (long g)
    throws LibGuestFSException;

  /**
   * update file timestamps or create a new file
   * <p>
   * Touch acts like the touch(1) command. It can be used to
   * update the timestamps on a file, or, if the file does
   * not exist, to create a new zero-length file.
   * <p>
   * @throws LibGuestFSException
   */
  public void touch (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("touch: handle is closed");
    _touch (g, path);
  }
  private native void _touch (long g, String path)
    throws LibGuestFSException;

  /**
   * list the contents of a file
   * <p>
   * Return the contents of the file named "path".
   * <p>
   * Note that this function cannot correctly handle binary
   * files (specifically, files containing "\0" character
   * which is treated as end of string). For those you need
   * to use the "g.download" function which has a more
   * complex interface.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String cat (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("cat: handle is closed");
    return _cat (g, path);
  }
  private native String _cat (long g, String path)
    throws LibGuestFSException;

  /**
   * list the files in a directory (long format)
   * <p>
   * List the files in "directory" (relative to the root
   * directory, there is no cwd) in the format of 'ls -la'.
   * <p>
   * This command is mostly useful for interactive sessions.
   * It is *not* intended that you try to parse the output
   * string.
   * <p>
   * @throws LibGuestFSException
   */
  public String ll (String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("ll: handle is closed");
    return _ll (g, directory);
  }
  private native String _ll (long g, String directory)
    throws LibGuestFSException;

  /**
   * list the files in a directory
   * <p>
   * List the files in "directory" (relative to the root
   * directory, there is no cwd). The '.' and '..' entries
   * are not returned, but hidden files are shown.
   * <p>
   * This command is mostly useful for interactive sessions.
   * Programs should probably use "g.readdir" instead.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] ls (String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("ls: handle is closed");
    return _ls (g, directory);
  }
  private native String[] _ls (long g, String directory)
    throws LibGuestFSException;

  /**
   * list the block devices
   * <p>
   * List all the block devices.
   * <p>
   * The full block device names are returned, eg. "/dev/sda"
   * <p>
   * @throws LibGuestFSException
   */
  public String[] list_devices ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("list_devices: handle is closed");
    return _list_devices (g);
  }
  private native String[] _list_devices (long g)
    throws LibGuestFSException;

  /**
   * list the partitions
   * <p>
   * List all the partitions detected on all block devices.
   * <p>
   * The full partition device names are returned, eg.
   * "/dev/sda1"
   * <p>
   * This does not return logical volumes. For that you will
   * need to call "g.lvs".
   * <p>
   * @throws LibGuestFSException
   */
  public String[] list_partitions ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("list_partitions: handle is closed");
    return _list_partitions (g);
  }
  private native String[] _list_partitions (long g)
    throws LibGuestFSException;

  /**
   * list the LVM physical volumes (PVs)
   * <p>
   * List all the physical volumes detected. This is the
   * equivalent of the pvs(8) command.
   * <p>
   * This returns a list of just the device names that
   * contain PVs (eg. "/dev/sda2").
   * <p>
   * See also "g.pvs_full".
   * <p>
   * @throws LibGuestFSException
   */
  public String[] pvs ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvs: handle is closed");
    return _pvs (g);
  }
  private native String[] _pvs (long g)
    throws LibGuestFSException;

  /**
   * list the LVM volume groups (VGs)
   * <p>
   * List all the volumes groups detected. This is the
   * equivalent of the vgs(8) command.
   * <p>
   * This returns a list of just the volume group names that
   * were detected (eg. "VolGroup00").
   * <p>
   * See also "g.vgs_full".
   * <p>
   * @throws LibGuestFSException
   */
  public String[] vgs ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgs: handle is closed");
    return _vgs (g);
  }
  private native String[] _vgs (long g)
    throws LibGuestFSException;

  /**
   * list the LVM logical volumes (LVs)
   * <p>
   * List all the logical volumes detected. This is the
   * equivalent of the lvs(8) command.
   * <p>
   * This returns a list of the logical volume device names
   * (eg. "/dev/VolGroup00/LogVol00").
   * <p>
   * See also "g.lvs_full".
   * <p>
   * @throws LibGuestFSException
   */
  public String[] lvs ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvs: handle is closed");
    return _lvs (g);
  }
  private native String[] _lvs (long g)
    throws LibGuestFSException;

  /**
   * list the LVM physical volumes (PVs)
   * <p>
   * List all the physical volumes detected. This is the
   * equivalent of the pvs(8) command. The "full" version
   * includes all fields.
   * <p>
   * @throws LibGuestFSException
   */
  public PV[] pvs_full ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvs_full: handle is closed");
    return _pvs_full (g);
  }
  private native PV[] _pvs_full (long g)
    throws LibGuestFSException;

  /**
   * list the LVM volume groups (VGs)
   * <p>
   * List all the volumes groups detected. This is the
   * equivalent of the vgs(8) command. The "full" version
   * includes all fields.
   * <p>
   * @throws LibGuestFSException
   */
  public VG[] vgs_full ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgs_full: handle is closed");
    return _vgs_full (g);
  }
  private native VG[] _vgs_full (long g)
    throws LibGuestFSException;

  /**
   * list the LVM logical volumes (LVs)
   * <p>
   * List all the logical volumes detected. This is the
   * equivalent of the lvs(8) command. The "full" version
   * includes all fields.
   * <p>
   * @throws LibGuestFSException
   */
  public LV[] lvs_full ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvs_full: handle is closed");
    return _lvs_full (g);
  }
  private native LV[] _lvs_full (long g)
    throws LibGuestFSException;

  /**
   * read file as lines
   * <p>
   * Return the contents of the file named "path".
   * <p>
   * The file contents are returned as a list of lines.
   * Trailing "LF" and "CRLF" character sequences are *not*
   * returned.
   * <p>
   * Note that this function cannot correctly handle binary
   * files (specifically, files containing "\0" character
   * which is treated as end of line). For those you need to
   * use the "g.read_file" function which has a more complex
   * interface.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] read_lines (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("read_lines: handle is closed");
    return _read_lines (g, path);
  }
  private native String[] _read_lines (long g, String path)
    throws LibGuestFSException;

  /**
   * create a new Augeas handle
   * <p>
   * Create a new Augeas handle for editing configuration
   * files. If there was any previous Augeas handle
   * associated with this guestfs session, then it is closed.
   * <p>
   * You must call this before using any other "g.aug_*"
   * commands.
   * <p>
   * "root" is the filesystem root. "root" must not be NULL,
   * use "/" instead.
   * <p>
   * The flags are the same as the flags defined in
   * <augeas.h>, the logical *or* of the following integers:
   * <p>
   * "AUG_SAVE_BACKUP" = 1
   * Keep the original file with a ".augsave" extension.
   * <p>
   * "AUG_SAVE_NEWFILE" = 2
   * Save changes into a file with extension ".augnew",
   * and do not overwrite original. Overrides
   * "AUG_SAVE_BACKUP".
   * <p>
   * "AUG_TYPE_CHECK" = 4
   * Typecheck lenses (can be expensive).
   * <p>
   * "AUG_NO_STDINC" = 8
   * Do not use standard load path for modules.
   * <p>
   * "AUG_SAVE_NOOP" = 16
   * Make save a no-op, just record what would have been
   * changed.
   * <p>
   * "AUG_NO_LOAD" = 32
   * Do not load the tree in "g.aug_init".
   * <p>
   * To close the handle, you can call "g.aug_close".
   * <p>
   * To find out more about Augeas, see <http://augeas.net/>.
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_init (String root, int flags)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_init: handle is closed");
    _aug_init (g, root, flags);
  }
  private native void _aug_init (long g, String root, int flags)
    throws LibGuestFSException;

  /**
   * close the current Augeas handle
   * <p>
   * Close the current Augeas handle and free up any
   * resources used by it. After calling this, you have to
   * call "g.aug_init" again before you can use any other
   * Augeas functions.
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_close ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_close: handle is closed");
    _aug_close (g);
  }
  private native void _aug_close (long g)
    throws LibGuestFSException;

  /**
   * define an Augeas variable
   * <p>
   * Defines an Augeas variable "name" whose value is the
   * result of evaluating "expr". If "expr" is NULL, then
   * "name" is undefined.
   * <p>
   * On success this returns the number of nodes in "expr",
   * or 0 if "expr" evaluates to something which is not a
   * nodeset.
   * <p>
   * @throws LibGuestFSException
   */
  public int aug_defvar (String name, String expr)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_defvar: handle is closed");
    return _aug_defvar (g, name, expr);
  }
  private native int _aug_defvar (long g, String name, String expr)
    throws LibGuestFSException;

  /**
   * define an Augeas node
   * <p>
   * Defines a variable "name" whose value is the result of
   * evaluating "expr".
   * <p>
   * If "expr" evaluates to an empty nodeset, a node is
   * created, equivalent to calling "g.aug_set" "expr",
   * "value". "name" will be the nodeset containing that
   * single node.
   * <p>
   * On success this returns a pair containing the number of
   * nodes in the nodeset, and a boolean flag if a node was
   * created.
   * <p>
   * @throws LibGuestFSException
   */
  public IntBool aug_defnode (String name, String expr, String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_defnode: handle is closed");
    return _aug_defnode (g, name, expr, val);
  }
  private native IntBool _aug_defnode (long g, String name, String expr, String val)
    throws LibGuestFSException;

  /**
   * look up the value of an Augeas path
   * <p>
   * Look up the value associated with "path". If "path"
   * matches exactly one node, the "value" is returned.
   * <p>
   * @throws LibGuestFSException
   */
  public String aug_get (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_get: handle is closed");
    return _aug_get (g, path);
  }
  private native String _aug_get (long g, String path)
    throws LibGuestFSException;

  /**
   * set Augeas path to value
   * <p>
   * Set the value associated with "path" to "value".
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_set (String path, String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_set: handle is closed");
    _aug_set (g, path, val);
  }
  private native void _aug_set (long g, String path, String val)
    throws LibGuestFSException;

  /**
   * insert a sibling Augeas node
   * <p>
   * Create a new sibling "label" for "path", inserting it
   * into the tree before or after "path" (depending on the
   * boolean flag "before").
   * <p>
   * "path" must match exactly one existing node in the tree,
   * and "label" must be a label, ie. not contain "/", "*" or
   * end with a bracketed index "[N]".
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_insert (String path, String label, boolean before)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_insert: handle is closed");
    _aug_insert (g, path, label, before);
  }
  private native void _aug_insert (long g, String path, String label, boolean before)
    throws LibGuestFSException;

  /**
   * remove an Augeas path
   * <p>
   * Remove "path" and all of its children.
   * <p>
   * On success this returns the number of entries which were
   * removed.
   * <p>
   * @throws LibGuestFSException
   */
  public int aug_rm (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_rm: handle is closed");
    return _aug_rm (g, path);
  }
  private native int _aug_rm (long g, String path)
    throws LibGuestFSException;

  /**
   * move Augeas node
   * <p>
   * Move the node "src" to "dest". "src" must match exactly
   * one node. "dest" is overwritten if it exists.
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_mv (String src, String dest)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_mv: handle is closed");
    _aug_mv (g, src, dest);
  }
  private native void _aug_mv (long g, String src, String dest)
    throws LibGuestFSException;

  /**
   * return Augeas nodes which match path
   * <p>
   * Returns a list of paths which match the path expression
   * "path". The returned paths are sufficiently qualified so
   * that they match exactly one node in the current tree.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] aug_match (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_match: handle is closed");
    return _aug_match (g, path);
  }
  private native String[] _aug_match (long g, String path)
    throws LibGuestFSException;

  /**
   * write all pending Augeas changes to disk
   * <p>
   * This writes all pending changes to disk.
   * <p>
   * The flags which were passed to "g.aug_init" affect
   * exactly how files are saved.
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_save ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_save: handle is closed");
    _aug_save (g);
  }
  private native void _aug_save (long g)
    throws LibGuestFSException;

  /**
   * load files into the tree
   * <p>
   * Load files into the tree.
   * <p>
   * See "aug_load" in the Augeas documentation for the full
   * gory details.
   * <p>
   * @throws LibGuestFSException
   */
  public void aug_load ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_load: handle is closed");
    _aug_load (g);
  }
  private native void _aug_load (long g)
    throws LibGuestFSException;

  /**
   * list Augeas nodes under a path
   * <p>
   * This is just a shortcut for listing "g.aug_match"
   * "path/*" and sorting the resulting nodes into
   * alphabetical order.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] aug_ls (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_ls: handle is closed");
    return _aug_ls (g, path);
  }
  private native String[] _aug_ls (long g, String path)
    throws LibGuestFSException;

  /**
   * remove a file
   * <p>
   * Remove the single file "path".
   * <p>
   * @throws LibGuestFSException
   */
  public void rm (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("rm: handle is closed");
    _rm (g, path);
  }
  private native void _rm (long g, String path)
    throws LibGuestFSException;

  /**
   * remove a directory
   * <p>
   * Remove the single directory "path".
   * <p>
   * @throws LibGuestFSException
   */
  public void rmdir (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("rmdir: handle is closed");
    _rmdir (g, path);
  }
  private native void _rmdir (long g, String path)
    throws LibGuestFSException;

  /**
   * remove a file or directory recursively
   * <p>
   * Remove the file or directory "path", recursively
   * removing the contents if its a directory. This is like
   * the "rm -rf" shell command.
   * <p>
   * @throws LibGuestFSException
   */
  public void rm_rf (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("rm_rf: handle is closed");
    _rm_rf (g, path);
  }
  private native void _rm_rf (long g, String path)
    throws LibGuestFSException;

  /**
   * create a directory
   * <p>
   * Create a directory named "path".
   * <p>
   * @throws LibGuestFSException
   */
  public void mkdir (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkdir: handle is closed");
    _mkdir (g, path);
  }
  private native void _mkdir (long g, String path)
    throws LibGuestFSException;

  /**
   * create a directory and parents
   * <p>
   * Create a directory named "path", creating any parent
   * directories as necessary. This is like the "mkdir -p"
   * shell command.
   * <p>
   * @throws LibGuestFSException
   */
  public void mkdir_p (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkdir_p: handle is closed");
    _mkdir_p (g, path);
  }
  private native void _mkdir_p (long g, String path)
    throws LibGuestFSException;

  /**
   * change file mode
   * <p>
   * Change the mode (permissions) of "path" to "mode". Only
   * numeric modes are supported.
   * <p>
   * @throws LibGuestFSException
   */
  public void chmod (int mode, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("chmod: handle is closed");
    _chmod (g, mode, path);
  }
  private native void _chmod (long g, int mode, String path)
    throws LibGuestFSException;

  /**
   * change file owner and group
   * <p>
   * Change the file owner to "owner" and group to "group".
   * <p>
   * Only numeric uid and gid are supported. If you want to
   * use names, you will need to locate and parse the
   * password file yourself (Augeas support makes this
   * relatively easy).
   * <p>
   * @throws LibGuestFSException
   */
  public void chown (int owner, int group, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("chown: handle is closed");
    _chown (g, owner, group, path);
  }
  private native void _chown (long g, int owner, int group, String path)
    throws LibGuestFSException;

  /**
   * test if file or directory exists
   * <p>
   * This returns "true" if and only if there is a file,
   * directory (or anything) with the given "path" name.
   * <p>
   * See also "g.is_file", "g.is_dir", "g.stat".
   * <p>
   * @throws LibGuestFSException
   */
  public boolean exists (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("exists: handle is closed");
    return _exists (g, path);
  }
  private native boolean _exists (long g, String path)
    throws LibGuestFSException;

  /**
   * test if file exists
   * <p>
   * This returns "true" if and only if there is a file with
   * the given "path" name. Note that it returns false for
   * other objects like directories.
   * <p>
   * See also "g.stat".
   * <p>
   * @throws LibGuestFSException
   */
  public boolean is_file (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_file: handle is closed");
    return _is_file (g, path);
  }
  private native boolean _is_file (long g, String path)
    throws LibGuestFSException;

  /**
   * test if file exists
   * <p>
   * This returns "true" if and only if there is a directory
   * with the given "path" name. Note that it returns false
   * for other objects like files.
   * <p>
   * See also "g.stat".
   * <p>
   * @throws LibGuestFSException
   */
  public boolean is_dir (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_dir: handle is closed");
    return _is_dir (g, path);
  }
  private native boolean _is_dir (long g, String path)
    throws LibGuestFSException;

  /**
   * create an LVM physical volume
   * <p>
   * This creates an LVM physical volume on the named
   * "device", where "device" should usually be a partition
   * name such as "/dev/sda1".
   * <p>
   * @throws LibGuestFSException
   */
  public void pvcreate (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvcreate: handle is closed");
    _pvcreate (g, device);
  }
  private native void _pvcreate (long g, String device)
    throws LibGuestFSException;

  /**
   * create an LVM volume group
   * <p>
   * This creates an LVM volume group called "volgroup" from
   * the non-empty list of physical volumes "physvols".
   * <p>
   * @throws LibGuestFSException
   */
  public void vgcreate (String volgroup, String[] physvols)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgcreate: handle is closed");
    _vgcreate (g, volgroup, physvols);
  }
  private native void _vgcreate (long g, String volgroup, String[] physvols)
    throws LibGuestFSException;

  /**
   * create an LVM volume group
   * <p>
   * This creates an LVM volume group called "logvol" on the
   * volume group "volgroup", with "size" megabytes.
   * <p>
   * @throws LibGuestFSException
   */
  public void lvcreate (String logvol, String volgroup, int mbytes)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvcreate: handle is closed");
    _lvcreate (g, logvol, volgroup, mbytes);
  }
  private native void _lvcreate (long g, String logvol, String volgroup, int mbytes)
    throws LibGuestFSException;

  /**
   * make a filesystem
   * <p>
   * This creates a filesystem on "device" (usually a
   * partition or LVM logical volume). The filesystem type is
   * "fstype", for example "ext3".
   * <p>
   * @throws LibGuestFSException
   */
  public void mkfs (String fstype, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkfs: handle is closed");
    _mkfs (g, fstype, device);
  }
  private native void _mkfs (long g, String fstype, String device)
    throws LibGuestFSException;

  /**
   * create partitions on a block device
   * <p>
   * This is a direct interface to the sfdisk(8) program for
   * creating partitions on block devices.
   * <p>
   * "device" should be a block device, for example
   * "/dev/sda".
   * <p>
   * "cyls", "heads" and "sectors" are the number of
   * cylinders, heads and sectors on the device, which are
   * passed directly to sfdisk as the *-C*, *-H* and *-S*
   * parameters. If you pass 0 for any of these, then the
   * corresponding parameter is omitted. Usually for 'large'
   * disks, you can just pass 0 for these, but for small
   * (floppy-sized) disks, sfdisk (or rather, the kernel)
   * cannot work out the right geometry and you will need to
   * tell it.
   * <p>
   * "lines" is a list of lines that we feed to "sfdisk". For
   * more information refer to the sfdisk(8) manpage.
   * <p>
   * To create a single partition occupying the whole disk,
   * you would pass "lines" as a single element list, when
   * the single element being the string "," (comma).
   * <p>
   * See also: "g.sfdisk_l", "g.sfdisk_N"
   * <p>
   * This command is dangerous. Without careful use you can
   * easily destroy all your data.
   * <p>
   * @throws LibGuestFSException
   */
  public void sfdisk (String device, int cyls, int heads, int sectors, String[] lines)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sfdisk: handle is closed");
    _sfdisk (g, device, cyls, heads, sectors, lines);
  }
  private native void _sfdisk (long g, String device, int cyls, int heads, int sectors, String[] lines)
    throws LibGuestFSException;

  /**
   * create a file
   * <p>
   * This call creates a file called "path". The contents of
   * the file is the string "content" (which can contain any
   * 8 bit data), with length "size".
   * <p>
   * As a special case, if "size" is 0 then the length is
   * calculated using "strlen" (so in this case the content
   * cannot contain embedded ASCII NULs).
   * <p>
   * *NB.* Owing to a bug, writing content containing ASCII
   * NUL characters does *not* work, even if the length is
   * specified. We hope to resolve this bug in a future
   * version. In the meantime use "g.upload".
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public void write_file (String path, String content, int size)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("write_file: handle is closed");
    _write_file (g, path, content, size);
  }
  private native void _write_file (long g, String path, String content, int size)
    throws LibGuestFSException;

  /**
   * unmount a filesystem
   * <p>
   * This unmounts the given filesystem. The filesystem may
   * be specified either by its mountpoint (path) or the
   * device which contains the filesystem.
   * <p>
   * @throws LibGuestFSException
   */
  public void umount (String pathordevice)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("umount: handle is closed");
    _umount (g, pathordevice);
  }
  private native void _umount (long g, String pathordevice)
    throws LibGuestFSException;

  /**
   * show mounted filesystems
   * <p>
   * This returns the list of currently mounted filesystems.
   * It returns the list of devices (eg. "/dev/sda1",
   * "/dev/VG/LV").
   * <p>
   * Some internal mounts are not shown.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] mounts ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mounts: handle is closed");
    return _mounts (g);
  }
  private native String[] _mounts (long g)
    throws LibGuestFSException;

  /**
   * unmount all filesystems
   * <p>
   * This unmounts all mounted filesystems.
   * <p>
   * Some internal mounts are not unmounted by this call.
   * <p>
   * @throws LibGuestFSException
   */
  public void umount_all ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("umount_all: handle is closed");
    _umount_all (g);
  }
  private native void _umount_all (long g)
    throws LibGuestFSException;

  /**
   * remove all LVM LVs, VGs and PVs
   * <p>
   * This command removes all LVM logical volumes, volume
   * groups and physical volumes.
   * <p>
   * This command is dangerous. Without careful use you can
   * easily destroy all your data.
   * <p>
   * @throws LibGuestFSException
   */
  public void lvm_remove_all ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvm_remove_all: handle is closed");
    _lvm_remove_all (g);
  }
  private native void _lvm_remove_all (long g)
    throws LibGuestFSException;

  /**
   * determine file type
   * <p>
   * This call uses the standard file(1) command to determine
   * the type or contents of the file. This also works on
   * devices, for example to find out whether a partition
   * contains a filesystem.
   * <p>
   * The exact command which runs is "file -bsL path". Note
   * in particular that the filename is not prepended to the
   * output (the "-b" option).
   * <p>
   * @throws LibGuestFSException
   */
  public String file (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("file: handle is closed");
    return _file (g, path);
  }
  private native String _file (long g, String path)
    throws LibGuestFSException;

  /**
   * run a command from the guest filesystem
   * <p>
   * This call runs a command from the guest filesystem. The
   * filesystem must be mounted, and must contain a
   * compatible operating system (ie. something Linux, with
   * the same or compatible processor architecture).
   * <p>
   * The single parameter is an argv-style list of arguments.
   * The first element is the name of the program to run.
   * Subsequent elements are parameters. The list must be
   * non-empty (ie. must contain a program name). Note that
   * the command runs directly, and is *not* invoked via the
   * shell (see "g.sh").
   * <p>
   * The return value is anything printed to *stdout* by the
   * command.
   * <p>
   * If the command returns a non-zero exit status, then this
   * function returns an error message. The error message
   * string is the content of *stderr* from the command.
   * <p>
   * The $PATH environment variable will contain at least
   * "/usr/bin" and "/bin". If you require a program from
   * another location, you should provide the full path in
   * the first parameter.
   * <p>
   * Shared libraries and data files required by the program
   * must be available on filesystems which are mounted in
   * the correct places. It is the caller's responsibility to
   * ensure all filesystems that are needed are mounted at
   * the right locations.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String command (String[] arguments)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("command: handle is closed");
    return _command (g, arguments);
  }
  private native String _command (long g, String[] arguments)
    throws LibGuestFSException;

  /**
   * run a command, returning lines
   * <p>
   * This is the same as "g.command", but splits the result
   * into a list of lines.
   * <p>
   * See also: "g.sh_lines"
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] command_lines (String[] arguments)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("command_lines: handle is closed");
    return _command_lines (g, arguments);
  }
  private native String[] _command_lines (long g, String[] arguments)
    throws LibGuestFSException;

  /**
   * get file information
   * <p>
   * Returns file information for the given "path".
   * <p>
   * This is the same as the stat(2) system call.
   * <p>
   * @throws LibGuestFSException
   */
  public Stat stat (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("stat: handle is closed");
    return _stat (g, path);
  }
  private native Stat _stat (long g, String path)
    throws LibGuestFSException;

  /**
   * get file information for a symbolic link
   * <p>
   * Returns file information for the given "path".
   * <p>
   * This is the same as "g.stat" except that if "path" is a
   * symbolic link, then the link is stat-ed, not the file it
   * refers to.
   * <p>
   * This is the same as the lstat(2) system call.
   * <p>
   * @throws LibGuestFSException
   */
  public Stat lstat (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lstat: handle is closed");
    return _lstat (g, path);
  }
  private native Stat _lstat (long g, String path)
    throws LibGuestFSException;

  /**
   * get file system statistics
   * <p>
   * Returns file system statistics for any mounted file
   * system. "path" should be a file or directory in the
   * mounted file system (typically it is the mount point
   * itself, but it doesn't need to be).
   * <p>
   * This is the same as the statvfs(2) system call.
   * <p>
   * @throws LibGuestFSException
   */
  public StatVFS statvfs (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("statvfs: handle is closed");
    return _statvfs (g, path);
  }
  private native StatVFS _statvfs (long g, String path)
    throws LibGuestFSException;

  /**
   * get ext2/ext3/ext4 superblock details
   * <p>
   * This returns the contents of the ext2, ext3 or ext4
   * filesystem superblock on "device".
   * <p>
   * It is the same as running "tune2fs -l device". See
   * tune2fs(8) manpage for more details. The list of fields
   * returned isn't clearly defined, and depends on both the
   * version of "tune2fs" that libguestfs was built against,
   * and the filesystem itself.
   * <p>
   * @throws LibGuestFSException
   */
  public HashMap<String,String> tune2fs_l (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tune2fs_l: handle is closed");
    return _tune2fs_l (g, device);
  }
  private native HashMap<String,String> _tune2fs_l (long g, String device)
    throws LibGuestFSException;

  /**
   * set block device to read-only
   * <p>
   * Sets the block device named "device" to read-only.
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public void blockdev_setro (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_setro: handle is closed");
    _blockdev_setro (g, device);
  }
  private native void _blockdev_setro (long g, String device)
    throws LibGuestFSException;

  /**
   * set block device to read-write
   * <p>
   * Sets the block device named "device" to read-write.
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public void blockdev_setrw (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_setrw: handle is closed");
    _blockdev_setrw (g, device);
  }
  private native void _blockdev_setrw (long g, String device)
    throws LibGuestFSException;

  /**
   * is block device set to read-only
   * <p>
   * Returns a boolean indicating if the block device is
   * read-only (true if read-only, false if not).
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public boolean blockdev_getro (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getro: handle is closed");
    return _blockdev_getro (g, device);
  }
  private native boolean _blockdev_getro (long g, String device)
    throws LibGuestFSException;

  /**
   * get sectorsize of block device
   * <p>
   * This returns the size of sectors on a block device.
   * Usually 512, but can be larger for modern devices.
   * <p>
   * (Note, this is not the size in sectors, use
   * "g.blockdev_getsz" for that).
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public int blockdev_getss (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getss: handle is closed");
    return _blockdev_getss (g, device);
  }
  private native int _blockdev_getss (long g, String device)
    throws LibGuestFSException;

  /**
   * get blocksize of block device
   * <p>
   * This returns the block size of a device.
   * <p>
   * (Note this is different from both *size in blocks* and
   * *filesystem block size*).
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public int blockdev_getbsz (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getbsz: handle is closed");
    return _blockdev_getbsz (g, device);
  }
  private native int _blockdev_getbsz (long g, String device)
    throws LibGuestFSException;

  /**
   * set blocksize of block device
   * <p>
   * This sets the block size of a device.
   * <p>
   * (Note this is different from both *size in blocks* and
   * *filesystem block size*).
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public void blockdev_setbsz (String device, int blocksize)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_setbsz: handle is closed");
    _blockdev_setbsz (g, device, blocksize);
  }
  private native void _blockdev_setbsz (long g, String device, int blocksize)
    throws LibGuestFSException;

  /**
   * get total size of device in 512-byte sectors
   * <p>
   * This returns the size of the device in units of 512-byte
   * sectors (even if the sectorsize isn't 512 bytes ...
   * weird).
   * <p>
   * See also "g.blockdev_getss" for the real sector size of
   * the device, and "g.blockdev_getsize64" for the more
   * useful *size in bytes*.
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public long blockdev_getsz (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getsz: handle is closed");
    return _blockdev_getsz (g, device);
  }
  private native long _blockdev_getsz (long g, String device)
    throws LibGuestFSException;

  /**
   * get total size of device in bytes
   * <p>
   * This returns the size of the device in bytes.
   * <p>
   * See also "g.blockdev_getsz".
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public long blockdev_getsize64 (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getsize64: handle is closed");
    return _blockdev_getsize64 (g, device);
  }
  private native long _blockdev_getsize64 (long g, String device)
    throws LibGuestFSException;

  /**
   * flush device buffers
   * <p>
   * This tells the kernel to flush internal buffers
   * associated with "device".
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public void blockdev_flushbufs (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_flushbufs: handle is closed");
    _blockdev_flushbufs (g, device);
  }
  private native void _blockdev_flushbufs (long g, String device)
    throws LibGuestFSException;

  /**
   * reread partition table
   * <p>
   * Reread the partition table on "device".
   * <p>
   * This uses the blockdev(8) command.
   * <p>
   * @throws LibGuestFSException
   */
  public void blockdev_rereadpt (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_rereadpt: handle is closed");
    _blockdev_rereadpt (g, device);
  }
  private native void _blockdev_rereadpt (long g, String device)
    throws LibGuestFSException;

  /**
   * upload a file from the local machine
   * <p>
   * Upload local file "filename" to "remotefilename" on the
   * filesystem.
   * <p>
   * "filename" can also be a named pipe.
   * <p>
   * See also "g.download".
   * <p>
   * @throws LibGuestFSException
   */
  public void upload (String filename, String remotefilename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("upload: handle is closed");
    _upload (g, filename, remotefilename);
  }
  private native void _upload (long g, String filename, String remotefilename)
    throws LibGuestFSException;

  /**
   * download a file to the local machine
   * <p>
   * Download file "remotefilename" and save it as "filename"
   * on the local machine.
   * <p>
   * "filename" can also be a named pipe.
   * <p>
   * See also "g.upload", "g.cat".
   * <p>
   * @throws LibGuestFSException
   */
  public void download (String remotefilename, String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("download: handle is closed");
    _download (g, remotefilename, filename);
  }
  private native void _download (long g, String remotefilename, String filename)
    throws LibGuestFSException;

  /**
   * compute MD5, SHAx or CRC checksum of file
   * <p>
   * This call computes the MD5, SHAx or CRC checksum of the
   * file named "path".
   * <p>
   * The type of checksum to compute is given by the
   * "csumtype" parameter which must have one of the
   * following values:
   * <p>
   * "crc"
   * Compute the cyclic redundancy check (CRC) specified
   * by POSIX for the "cksum" command.
   * <p>
   * "md5"
   * Compute the MD5 hash (using the "md5sum" program).
   * <p>
   * "sha1"
   * Compute the SHA1 hash (using the "sha1sum" program).
   * <p>
   * "sha224"
   * Compute the SHA224 hash (using the "sha224sum"
   * program).
   * <p>
   * "sha256"
   * Compute the SHA256 hash (using the "sha256sum"
   * program).
   * <p>
   * "sha384"
   * Compute the SHA384 hash (using the "sha384sum"
   * program).
   * <p>
   * "sha512"
   * Compute the SHA512 hash (using the "sha512sum"
   * program).
   * <p>
   * The checksum is returned as a printable string.
   * <p>
   * @throws LibGuestFSException
   */
  public String checksum (String csumtype, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("checksum: handle is closed");
    return _checksum (g, csumtype, path);
  }
  private native String _checksum (long g, String csumtype, String path)
    throws LibGuestFSException;

  /**
   * unpack tarfile to directory
   * <p>
   * This command uploads and unpacks local file "tarfile"
   * (an *uncompressed* tar file) into "directory".
   * <p>
   * To upload a compressed tarball, use "g.tgz_in".
   * <p>
   * @throws LibGuestFSException
   */
  public void tar_in (String tarfile, String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tar_in: handle is closed");
    _tar_in (g, tarfile, directory);
  }
  private native void _tar_in (long g, String tarfile, String directory)
    throws LibGuestFSException;

  /**
   * pack directory into tarfile
   * <p>
   * This command packs the contents of "directory" and
   * downloads it to local file "tarfile".
   * <p>
   * To download a compressed tarball, use "g.tgz_out".
   * <p>
   * @throws LibGuestFSException
   */
  public void tar_out (String directory, String tarfile)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tar_out: handle is closed");
    _tar_out (g, directory, tarfile);
  }
  private native void _tar_out (long g, String directory, String tarfile)
    throws LibGuestFSException;

  /**
   * unpack compressed tarball to directory
   * <p>
   * This command uploads and unpacks local file "tarball" (a
   * *gzip compressed* tar file) into "directory".
   * <p>
   * To upload an uncompressed tarball, use "g.tar_in".
   * <p>
   * @throws LibGuestFSException
   */
  public void tgz_in (String tarball, String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tgz_in: handle is closed");
    _tgz_in (g, tarball, directory);
  }
  private native void _tgz_in (long g, String tarball, String directory)
    throws LibGuestFSException;

  /**
   * pack directory into compressed tarball
   * <p>
   * This command packs the contents of "directory" and
   * downloads it to local file "tarball".
   * <p>
   * To download an uncompressed tarball, use "g.tar_out".
   * <p>
   * @throws LibGuestFSException
   */
  public void tgz_out (String directory, String tarball)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tgz_out: handle is closed");
    _tgz_out (g, directory, tarball);
  }
  private native void _tgz_out (long g, String directory, String tarball)
    throws LibGuestFSException;

  /**
   * mount a guest disk, read-only
   * <p>
   * This is the same as the "g.mount" command, but it mounts
   * the filesystem with the read-only (*-o ro*) flag.
   * <p>
   * @throws LibGuestFSException
   */
  public void mount_ro (String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_ro: handle is closed");
    _mount_ro (g, device, mountpoint);
  }
  private native void _mount_ro (long g, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * mount a guest disk with mount options
   * <p>
   * This is the same as the "g.mount" command, but it allows
   * you to set the mount options as for the mount(8) *-o*
   * flag.
   * <p>
   * @throws LibGuestFSException
   */
  public void mount_options (String options, String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_options: handle is closed");
    _mount_options (g, options, device, mountpoint);
  }
  private native void _mount_options (long g, String options, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * mount a guest disk with mount options and vfstype
   * <p>
   * This is the same as the "g.mount" command, but it allows
   * you to set both the mount options and the vfstype as for
   * the mount(8) *-o* and *-t* flags.
   * <p>
   * @throws LibGuestFSException
   */
  public void mount_vfs (String options, String vfstype, String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_vfs: handle is closed");
    _mount_vfs (g, options, vfstype, device, mountpoint);
  }
  private native void _mount_vfs (long g, String options, String vfstype, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * debugging and internals
   * <p>
   * The "g.debug" command exposes some internals of
   * "guestfsd" (the guestfs daemon) that runs inside the
   * qemu subprocess.
   * <p>
   * There is no comprehensive help for this command. You
   * have to look at the file "daemon/debug.c" in the
   * libguestfs source to find out what you can do.
   * <p>
   * @throws LibGuestFSException
   */
  public String debug (String subcmd, String[] extraargs)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("debug: handle is closed");
    return _debug (g, subcmd, extraargs);
  }
  private native String _debug (long g, String subcmd, String[] extraargs)
    throws LibGuestFSException;

  /**
   * remove an LVM logical volume
   * <p>
   * Remove an LVM logical volume "device", where "device" is
   * the path to the LV, such as "/dev/VG/LV".
   * <p>
   * You can also remove all LVs in a volume group by
   * specifying the VG name, "/dev/VG".
   * <p>
   * @throws LibGuestFSException
   */
  public void lvremove (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvremove: handle is closed");
    _lvremove (g, device);
  }
  private native void _lvremove (long g, String device)
    throws LibGuestFSException;

  /**
   * remove an LVM volume group
   * <p>
   * Remove an LVM volume group "vgname", (for example "VG").
   * <p>
   * This also forcibly removes all logical volumes in the
   * volume group (if any).
   * <p>
   * @throws LibGuestFSException
   */
  public void vgremove (String vgname)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgremove: handle is closed");
    _vgremove (g, vgname);
  }
  private native void _vgremove (long g, String vgname)
    throws LibGuestFSException;

  /**
   * remove an LVM physical volume
   * <p>
   * This wipes a physical volume "device" so that LVM will
   * no longer recognise it.
   * <p>
   * The implementation uses the "pvremove" command which
   * refuses to wipe physical volumes that contain any volume
   * groups, so you have to remove those first.
   * <p>
   * @throws LibGuestFSException
   */
  public void pvremove (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvremove: handle is closed");
    _pvremove (g, device);
  }
  private native void _pvremove (long g, String device)
    throws LibGuestFSException;

  /**
   * set the ext2/3/4 filesystem label
   * <p>
   * This sets the ext2/3/4 filesystem label of the
   * filesystem on "device" to "label". Filesystem labels are
   * limited to 16 characters.
   * <p>
   * You can use either "g.tune2fs_l" or "g.get_e2label" to
   * return the existing label on a filesystem.
   * <p>
   * @throws LibGuestFSException
   */
  public void set_e2label (String device, String label)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_e2label: handle is closed");
    _set_e2label (g, device, label);
  }
  private native void _set_e2label (long g, String device, String label)
    throws LibGuestFSException;

  /**
   * get the ext2/3/4 filesystem label
   * <p>
   * This returns the ext2/3/4 filesystem label of the
   * filesystem on "device".
   * <p>
   * @throws LibGuestFSException
   */
  public String get_e2label (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_e2label: handle is closed");
    return _get_e2label (g, device);
  }
  private native String _get_e2label (long g, String device)
    throws LibGuestFSException;

  /**
   * set the ext2/3/4 filesystem UUID
   * <p>
   * This sets the ext2/3/4 filesystem UUID of the filesystem
   * on "device" to "uuid". The format of the UUID and
   * alternatives such as "clear", "random" and "time" are
   * described in the tune2fs(8) manpage.
   * <p>
   * You can use either "g.tune2fs_l" or "g.get_e2uuid" to
   * return the existing UUID of a filesystem.
   * <p>
   * @throws LibGuestFSException
   */
  public void set_e2uuid (String device, String uuid)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_e2uuid: handle is closed");
    _set_e2uuid (g, device, uuid);
  }
  private native void _set_e2uuid (long g, String device, String uuid)
    throws LibGuestFSException;

  /**
   * get the ext2/3/4 filesystem UUID
   * <p>
   * This returns the ext2/3/4 filesystem UUID of the
   * filesystem on "device".
   * <p>
   * @throws LibGuestFSException
   */
  public String get_e2uuid (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_e2uuid: handle is closed");
    return _get_e2uuid (g, device);
  }
  private native String _get_e2uuid (long g, String device)
    throws LibGuestFSException;

  /**
   * run the filesystem checker
   * <p>
   * This runs the filesystem checker (fsck) on "device"
   * which should have filesystem type "fstype".
   * <p>
   * The returned integer is the status. See fsck(8) for the
   * list of status codes from "fsck".
   * <p>
   * Notes:
   * <p>
   * *   Multiple status codes can be summed together.
   * <p>
   * *   A non-zero return code can mean "success", for
   * example if errors have been corrected on the
   * filesystem.
   * <p>
   * *   Checking or repairing NTFS volumes is not supported
   * (by linux-ntfs).
   * <p>
   * This command is entirely equivalent to running "fsck -a
   * -t fstype device".
   * <p>
   * @throws LibGuestFSException
   */
  public int fsck (String fstype, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("fsck: handle is closed");
    return _fsck (g, fstype, device);
  }
  private native int _fsck (long g, String fstype, String device)
    throws LibGuestFSException;

  /**
   * write zeroes to the device
   * <p>
   * This command writes zeroes over the first few blocks of
   * "device".
   * <p>
   * How many blocks are zeroed isn't specified (but it's
   * *not* enough to securely wipe the device). It should be
   * sufficient to remove any partition tables, filesystem
   * superblocks and so on.
   * <p>
   * See also: "g.scrub_device".
   * <p>
   * @throws LibGuestFSException
   */
  public void zero (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("zero: handle is closed");
    _zero (g, device);
  }
  private native void _zero (long g, String device)
    throws LibGuestFSException;

  /**
   * install GRUB
   * <p>
   * This command installs GRUB (the Grand Unified
   * Bootloader) on "device", with the root directory being
   * "root".
   * <p>
   * @throws LibGuestFSException
   */
  public void grub_install (String root, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("grub_install: handle is closed");
    _grub_install (g, root, device);
  }
  private native void _grub_install (long g, String root, String device)
    throws LibGuestFSException;

  /**
   * copy a file
   * <p>
   * This copies a file from "src" to "dest" where "dest" is
   * either a destination filename or destination directory.
   * <p>
   * @throws LibGuestFSException
   */
  public void cp (String src, String dest)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("cp: handle is closed");
    _cp (g, src, dest);
  }
  private native void _cp (long g, String src, String dest)
    throws LibGuestFSException;

  /**
   * copy a file or directory recursively
   * <p>
   * This copies a file or directory from "src" to "dest"
   * recursively using the "cp -a" command.
   * <p>
   * @throws LibGuestFSException
   */
  public void cp_a (String src, String dest)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("cp_a: handle is closed");
    _cp_a (g, src, dest);
  }
  private native void _cp_a (long g, String src, String dest)
    throws LibGuestFSException;

  /**
   * move a file
   * <p>
   * This moves a file from "src" to "dest" where "dest" is
   * either a destination filename or destination directory.
   * <p>
   * @throws LibGuestFSException
   */
  public void mv (String src, String dest)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mv: handle is closed");
    _mv (g, src, dest);
  }
  private native void _mv (long g, String src, String dest)
    throws LibGuestFSException;

  /**
   * drop kernel page cache, dentries and inodes
   * <p>
   * This instructs the guest kernel to drop its page cache,
   * and/or dentries and inode caches. The parameter
   * "whattodrop" tells the kernel what precisely to drop,
   * see <http://linux-mm.org/Drop_Caches>
   * <p>
   * Setting "whattodrop" to 3 should drop everything.
   * <p>
   * This automatically calls sync(2) before the operation,
   * so that the maximum guest memory is freed.
   * <p>
   * @throws LibGuestFSException
   */
  public void drop_caches (int whattodrop)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("drop_caches: handle is closed");
    _drop_caches (g, whattodrop);
  }
  private native void _drop_caches (long g, int whattodrop)
    throws LibGuestFSException;

  /**
   * return kernel messages
   * <p>
   * This returns the kernel messages ("dmesg" output) from
   * the guest kernel. This is sometimes useful for extended
   * debugging of problems.
   * <p>
   * Another way to get the same information is to enable
   * verbose messages with "g.set_verbose" or by setting the
   * environment variable "LIBGUESTFS_DEBUG=1" before running
   * the program.
   * <p>
   * @throws LibGuestFSException
   */
  public String dmesg ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("dmesg: handle is closed");
    return _dmesg (g);
  }
  private native String _dmesg (long g)
    throws LibGuestFSException;

  /**
   * ping the guest daemon
   * <p>
   * This is a test probe into the guestfs daemon running
   * inside the qemu subprocess. Calling this function checks
   * that the daemon responds to the ping message, without
   * affecting the daemon or attached block device(s) in any
   * other way.
   * <p>
   * @throws LibGuestFSException
   */
  public void ping_daemon ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("ping_daemon: handle is closed");
    _ping_daemon (g);
  }
  private native void _ping_daemon (long g)
    throws LibGuestFSException;

  /**
   * test if two files have equal contents
   * <p>
   * This compares the two files "file1" and "file2" and
   * returns true if their content is exactly equal, or false
   * otherwise.
   * <p>
   * The external cmp(1) program is used for the comparison.
   * <p>
   * @throws LibGuestFSException
   */
  public boolean equal (String file1, String file2)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("equal: handle is closed");
    return _equal (g, file1, file2);
  }
  private native boolean _equal (long g, String file1, String file2)
    throws LibGuestFSException;

  /**
   * print the printable strings in a file
   * <p>
   * This runs the strings(1) command on a file and returns
   * the list of printable strings found.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] strings (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("strings: handle is closed");
    return _strings (g, path);
  }
  private native String[] _strings (long g, String path)
    throws LibGuestFSException;

  /**
   * print the printable strings in a file
   * <p>
   * This is like the "g.strings" command, but allows you to
   * specify the encoding.
   * <p>
   * See the strings(1) manpage for the full list of
   * encodings.
   * <p>
   * Commonly useful encodings are "l" (lower case L) which
   * will show strings inside Windows/x86 files.
   * <p>
   * The returned strings are transcoded to UTF-8.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] strings_e (String encoding, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("strings_e: handle is closed");
    return _strings_e (g, encoding, path);
  }
  private native String[] _strings_e (long g, String encoding, String path)
    throws LibGuestFSException;

  /**
   * dump a file in hexadecimal
   * <p>
   * This runs "hexdump -C" on the given "path". The result
   * is the human-readable, canonical hex dump of the file.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String hexdump (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("hexdump: handle is closed");
    return _hexdump (g, path);
  }
  private native String _hexdump (long g, String path)
    throws LibGuestFSException;

  /**
   * zero unused inodes and disk blocks on ext2/3 filesystem
   * <p>
   * This runs the *zerofree* program on "device". This
   * program claims to zero unused inodes and disk blocks on
   * an ext2/3 filesystem, thus making it possible to
   * compress the filesystem more effectively.
   * <p>
   * You should not run this program if the filesystem is
   * mounted.
   * <p>
   * It is possible that using this program can damage the
   * filesystem or data on the filesystem.
   * <p>
   * @throws LibGuestFSException
   */
  public void zerofree (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("zerofree: handle is closed");
    _zerofree (g, device);
  }
  private native void _zerofree (long g, String device)
    throws LibGuestFSException;

  /**
   * resize an LVM physical volume
   * <p>
   * This resizes (expands or shrinks) an existing LVM
   * physical volume to match the new size of the underlying
   * device.
   * <p>
   * @throws LibGuestFSException
   */
  public void pvresize (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvresize: handle is closed");
    _pvresize (g, device);
  }
  private native void _pvresize (long g, String device)
    throws LibGuestFSException;

  /**
   * modify a single partition on a block device
   * <p>
   * This runs sfdisk(8) option to modify just the single
   * partition "n" (note: "n" counts from 1).
   * <p>
   * For other parameters, see "g.sfdisk". You should usually
   * pass 0 for the cyls/heads/sectors parameters.
   * <p>
   * This command is dangerous. Without careful use you can
   * easily destroy all your data.
   * <p>
   * @throws LibGuestFSException
   */
  public void sfdisk_N (String device, int partnum, int cyls, int heads, int sectors, String line)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sfdisk_N: handle is closed");
    _sfdisk_N (g, device, partnum, cyls, heads, sectors, line);
  }
  private native void _sfdisk_N (long g, String device, int partnum, int cyls, int heads, int sectors, String line)
    throws LibGuestFSException;

  /**
   * display the partition table
   * <p>
   * This displays the partition table on "device", in the
   * human-readable output of the sfdisk(8) command. It is
   * not intended to be parsed.
   * <p>
   * @throws LibGuestFSException
   */
  public String sfdisk_l (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sfdisk_l: handle is closed");
    return _sfdisk_l (g, device);
  }
  private native String _sfdisk_l (long g, String device)
    throws LibGuestFSException;

  /**
   * display the kernel geometry
   * <p>
   * This displays the kernel's idea of the geometry of
   * "device".
   * <p>
   * The result is in human-readable format, and not designed
   * to be parsed.
   * <p>
   * @throws LibGuestFSException
   */
  public String sfdisk_kernel_geometry (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sfdisk_kernel_geometry: handle is closed");
    return _sfdisk_kernel_geometry (g, device);
  }
  private native String _sfdisk_kernel_geometry (long g, String device)
    throws LibGuestFSException;

  /**
   * display the disk geometry from the partition table
   * <p>
   * This displays the disk geometry of "device" read from
   * the partition table. Especially in the case where the
   * underlying block device has been resized, this can be
   * different from the kernel's idea of the geometry (see
   * "g.sfdisk_kernel_geometry").
   * <p>
   * The result is in human-readable format, and not designed
   * to be parsed.
   * <p>
   * @throws LibGuestFSException
   */
  public String sfdisk_disk_geometry (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sfdisk_disk_geometry: handle is closed");
    return _sfdisk_disk_geometry (g, device);
  }
  private native String _sfdisk_disk_geometry (long g, String device)
    throws LibGuestFSException;

  /**
   * activate or deactivate all volume groups
   * <p>
   * This command activates or (if "activate" is false)
   * deactivates all logical volumes in all volume groups. If
   * activated, then they are made known to the kernel, ie.
   * they appear as "/dev/mapper" devices. If deactivated,
   * then those devices disappear.
   * <p>
   * This command is the same as running "vgchange -a y|n"
   * <p>
   * @throws LibGuestFSException
   */
  public void vg_activate_all (boolean activate)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vg_activate_all: handle is closed");
    _vg_activate_all (g, activate);
  }
  private native void _vg_activate_all (long g, boolean activate)
    throws LibGuestFSException;

  /**
   * activate or deactivate some volume groups
   * <p>
   * This command activates or (if "activate" is false)
   * deactivates all logical volumes in the listed volume
   * groups "volgroups". If activated, then they are made
   * known to the kernel, ie. they appear as "/dev/mapper"
   * devices. If deactivated, then those devices disappear.
   * <p>
   * This command is the same as running "vgchange -a y|n
   * volgroups..."
   * <p>
   * Note that if "volgroups" is an empty list then all
   * volume groups are activated or deactivated.
   * <p>
   * @throws LibGuestFSException
   */
  public void vg_activate (boolean activate, String[] volgroups)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vg_activate: handle is closed");
    _vg_activate (g, activate, volgroups);
  }
  private native void _vg_activate (long g, boolean activate, String[] volgroups)
    throws LibGuestFSException;

  /**
   * resize an LVM logical volume
   * <p>
   * This resizes (expands or shrinks) an existing LVM
   * logical volume to "mbytes". When reducing, data in the
   * reduced part is lost.
   * <p>
   * @throws LibGuestFSException
   */
  public void lvresize (String device, int mbytes)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvresize: handle is closed");
    _lvresize (g, device, mbytes);
  }
  private native void _lvresize (long g, String device, int mbytes)
    throws LibGuestFSException;

  /**
   * resize an ext2/ext3 filesystem
   * <p>
   * This resizes an ext2 or ext3 filesystem to match the
   * size of the underlying device.
   * <p>
   * *Note:* It is sometimes required that you run
   * "g.e2fsck_f" on the "device" before calling this
   * command. For unknown reasons "resize2fs" sometimes gives
   * an error about this and sometimes not. In any case, it
   * is always safe to call "g.e2fsck_f" before calling this
   * function.
   * <p>
   * @throws LibGuestFSException
   */
  public void resize2fs (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("resize2fs: handle is closed");
    _resize2fs (g, device);
  }
  private native void _resize2fs (long g, String device)
    throws LibGuestFSException;

  /**
   * find all files and directories
   * <p>
   * This command lists out all files and directories,
   * recursively, starting at "directory". It is essentially
   * equivalent to running the shell command "find directory
   * -print" but some post-processing happens on the output,
   * described below.
   * <p>
   * This returns a list of strings *without any prefix*.
   * Thus if the directory structure was:
   * <p>
   * /tmp/a
   * /tmp/b
   * /tmp/c/d
   * <p>
   * then the returned list from "g.find" "/tmp" would be 4
   * elements:
   * <p>
   * a
   * b
   * c
   * c/d
   * <p>
   * If "directory" is not a directory, then this command
   * returns an error.
   * <p>
   * The returned list is sorted.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] find (String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("find: handle is closed");
    return _find (g, directory);
  }
  private native String[] _find (long g, String directory)
    throws LibGuestFSException;

  /**
   * check an ext2/ext3 filesystem
   * <p>
   * This runs "e2fsck -p -f device", ie. runs the ext2/ext3
   * filesystem checker on "device", noninteractively ("-p"),
   * even if the filesystem appears to be clean ("-f").
   * <p>
   * This command is only needed because of "g.resize2fs"
   * (q.v.). Normally you should use "g.fsck".
   * <p>
   * @throws LibGuestFSException
   */
  public void e2fsck_f (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("e2fsck_f: handle is closed");
    _e2fsck_f (g, device);
  }
  private native void _e2fsck_f (long g, String device)
    throws LibGuestFSException;

  /**
   * sleep for some seconds
   * <p>
   * Sleep for "secs" seconds.
   * <p>
   * @throws LibGuestFSException
   */
  public void sleep (int secs)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sleep: handle is closed");
    _sleep (g, secs);
  }
  private native void _sleep (long g, int secs)
    throws LibGuestFSException;

  /**
   * probe NTFS volume
   * <p>
   * This command runs the ntfs-3g.probe(8) command which
   * probes an NTFS "device" for mountability. (Not all NTFS
   * volumes can be mounted read-write, and some cannot be
   * mounted at all).
   * <p>
   * "rw" is a boolean flag. Set it to true if you want to
   * test if the volume can be mounted read-write. Set it to
   * false if you want to test if the volume can be mounted
   * read-only.
   * <p>
   * The return value is an integer which 0 if the operation
   * would succeed, or some non-zero value documented in the
   * ntfs-3g.probe(8) manual page.
   * <p>
   * @throws LibGuestFSException
   */
  public int ntfs_3g_probe (boolean rw, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("ntfs_3g_probe: handle is closed");
    return _ntfs_3g_probe (g, rw, device);
  }
  private native int _ntfs_3g_probe (long g, boolean rw, String device)
    throws LibGuestFSException;

  /**
   * run a command via the shell
   * <p>
   * This call runs a command from the guest filesystem via
   * the guest's "/bin/sh".
   * <p>
   * This is like "g.command", but passes the command to:
   * <p>
   * /bin/sh -c "command"
   * <p>
   * Depending on the guest's shell, this usually results in
   * wildcards being expanded, shell expressions being
   * interpolated and so on.
   * <p>
   * All the provisos about "g.command" apply to this call.
   * <p>
   * @throws LibGuestFSException
   */
  public String sh (String command)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sh: handle is closed");
    return _sh (g, command);
  }
  private native String _sh (long g, String command)
    throws LibGuestFSException;

  /**
   * run a command via the shell returning lines
   * <p>
   * This is the same as "g.sh", but splits the result into a
   * list of lines.
   * <p>
   * See also: "g.command_lines"
   * <p>
   * @throws LibGuestFSException
   */
  public String[] sh_lines (String command)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sh_lines: handle is closed");
    return _sh_lines (g, command);
  }
  private native String[] _sh_lines (long g, String command)
    throws LibGuestFSException;

  /**
   * expand a wildcard path
   * <p>
   * This command searches for all the pathnames matching
   * "pattern" according to the wildcard expansion rules used
   * by the shell.
   * <p>
   * If no paths match, then this returns an empty list
   * (note: not an error).
   * <p>
   * It is just a wrapper around the C glob(3) function with
   * flags "GLOB_MARK|GLOB_BRACE". See that manual page for
   * more details.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] glob_expand (String pattern)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("glob_expand: handle is closed");
    return _glob_expand (g, pattern);
  }
  private native String[] _glob_expand (long g, String pattern)
    throws LibGuestFSException;

  /**
   * scrub (securely wipe) a device
   * <p>
   * This command writes patterns over "device" to make data
   * retrieval more difficult.
   * <p>
   * It is an interface to the scrub(1) program. See that
   * manual page for more details.
   * <p>
   * This command is dangerous. Without careful use you can
   * easily destroy all your data.
   * <p>
   * @throws LibGuestFSException
   */
  public void scrub_device (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("scrub_device: handle is closed");
    _scrub_device (g, device);
  }
  private native void _scrub_device (long g, String device)
    throws LibGuestFSException;

  /**
   * scrub (securely wipe) a file
   * <p>
   * This command writes patterns over a file to make data
   * retrieval more difficult.
   * <p>
   * The file is *removed* after scrubbing.
   * <p>
   * It is an interface to the scrub(1) program. See that
   * manual page for more details.
   * <p>
   * @throws LibGuestFSException
   */
  public void scrub_file (String file)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("scrub_file: handle is closed");
    _scrub_file (g, file);
  }
  private native void _scrub_file (long g, String file)
    throws LibGuestFSException;

  /**
   * scrub (securely wipe) free space
   * <p>
   * This command creates the directory "dir" and then fills
   * it with files until the filesystem is full, and scrubs
   * the files as for "g.scrub_file", and deletes them. The
   * intention is to scrub any free space on the partition
   * containing "dir".
   * <p>
   * It is an interface to the scrub(1) program. See that
   * manual page for more details.
   * <p>
   * @throws LibGuestFSException
   */
  public void scrub_freespace (String dir)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("scrub_freespace: handle is closed");
    _scrub_freespace (g, dir);
  }
  private native void _scrub_freespace (long g, String dir)
    throws LibGuestFSException;

  /**
   * create a temporary directory
   * <p>
   * This command creates a temporary directory. The
   * "template" parameter should be a full pathname for the
   * temporary directory name with the final six characters
   * being "XXXXXX".
   * <p>
   * For example: "/tmp/myprogXXXXXX" or
   * "/Temp/myprogXXXXXX", the second one being suitable for
   * Windows filesystems.
   * <p>
   * The name of the temporary directory that was created is
   * returned.
   * <p>
   * The temporary directory is created with mode 0700 and is
   * owned by root.
   * <p>
   * The caller is responsible for deleting the temporary
   * directory and its contents after use.
   * <p>
   * See also: mkdtemp(3)
   * <p>
   * @throws LibGuestFSException
   */
  public String mkdtemp (String template)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkdtemp: handle is closed");
    return _mkdtemp (g, template);
  }
  private native String _mkdtemp (long g, String template)
    throws LibGuestFSException;

  /**
   * count lines in a file
   * <p>
   * This command counts the lines in a file, using the "wc
   * -l" external command.
   * <p>
   * @throws LibGuestFSException
   */
  public int wc_l (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("wc_l: handle is closed");
    return _wc_l (g, path);
  }
  private native int _wc_l (long g, String path)
    throws LibGuestFSException;

  /**
   * count words in a file
   * <p>
   * This command counts the words in a file, using the "wc
   * -w" external command.
   * <p>
   * @throws LibGuestFSException
   */
  public int wc_w (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("wc_w: handle is closed");
    return _wc_w (g, path);
  }
  private native int _wc_w (long g, String path)
    throws LibGuestFSException;

  /**
   * count characters in a file
   * <p>
   * This command counts the characters in a file, using the
   * "wc -c" external command.
   * <p>
   * @throws LibGuestFSException
   */
  public int wc_c (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("wc_c: handle is closed");
    return _wc_c (g, path);
  }
  private native int _wc_c (long g, String path)
    throws LibGuestFSException;

  /**
   * return first 10 lines of a file
   * <p>
   * This command returns up to the first 10 lines of a file
   * as a list of strings.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] head (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("head: handle is closed");
    return _head (g, path);
  }
  private native String[] _head (long g, String path)
    throws LibGuestFSException;

  /**
   * return first N lines of a file
   * <p>
   * If the parameter "nrlines" is a positive number, this
   * returns the first "nrlines" lines of the file "path".
   * <p>
   * If the parameter "nrlines" is a negative number, this
   * returns lines from the file "path", excluding the last
   * "nrlines" lines.
   * <p>
   * If the parameter "nrlines" is zero, this returns an
   * empty list.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] head_n (int nrlines, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("head_n: handle is closed");
    return _head_n (g, nrlines, path);
  }
  private native String[] _head_n (long g, int nrlines, String path)
    throws LibGuestFSException;

  /**
   * return last 10 lines of a file
   * <p>
   * This command returns up to the last 10 lines of a file
   * as a list of strings.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] tail (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tail: handle is closed");
    return _tail (g, path);
  }
  private native String[] _tail (long g, String path)
    throws LibGuestFSException;

  /**
   * return last N lines of a file
   * <p>
   * If the parameter "nrlines" is a positive number, this
   * returns the last "nrlines" lines of the file "path".
   * <p>
   * If the parameter "nrlines" is a negative number, this
   * returns lines from the file "path", starting with the
   * "-nrlines"th line.
   * <p>
   * If the parameter "nrlines" is zero, this returns an
   * empty list.
   * <p>
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * <p>
   * @throws LibGuestFSException
   */
  public String[] tail_n (int nrlines, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tail_n: handle is closed");
    return _tail_n (g, nrlines, path);
  }
  private native String[] _tail_n (long g, int nrlines, String path)
    throws LibGuestFSException;

  /**
   * report file system disk space usage
   * <p>
   * This command runs the "df" command to report disk space
   * used.
   * <p>
   * This command is mostly useful for interactive sessions.
   * It is *not* intended that you try to parse the output
   * string. Use "statvfs" from programs.
   * <p>
   * @throws LibGuestFSException
   */
  public String df ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("df: handle is closed");
    return _df (g);
  }
  private native String _df (long g)
    throws LibGuestFSException;

  /**
   * report file system disk space usage (human readable)
   * <p>
   * This command runs the "df -h" command to report disk
   * space used in human-readable format.
   * <p>
   * This command is mostly useful for interactive sessions.
   * It is *not* intended that you try to parse the output
   * string. Use "statvfs" from programs.
   * <p>
   * @throws LibGuestFSException
   */
  public String df_h ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("df_h: handle is closed");
    return _df_h (g);
  }
  private native String _df_h (long g)
    throws LibGuestFSException;

  /**
   * estimate file space usage
   * <p>
   * This command runs the "du -s" command to estimate file
   * space usage for "path".
   * <p>
   * "path" can be a file or a directory. If "path" is a
   * directory then the estimate includes the contents of the
   * directory and all subdirectories (recursively).
   * <p>
   * The result is the estimated size in *kilobytes* (ie.
   * units of 1024 bytes).
   * <p>
   * @throws LibGuestFSException
   */
  public long du (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("du: handle is closed");
    return _du (g, path);
  }
  private native long _du (long g, String path)
    throws LibGuestFSException;

  /**
   * list files in an initrd
   * <p>
   * This command lists out files contained in an initrd.
   * <p>
   * The files are listed without any initial "/" character.
   * The files are listed in the order they appear (not
   * necessarily alphabetical). Directory names are listed as
   * separate items.
   * <p>
   * Old Linux kernels (2.4 and earlier) used a compressed
   * ext2 filesystem as initrd. We *only* support the newer
   * initramfs format (compressed cpio files).
   * <p>
   * @throws LibGuestFSException
   */
  public String[] initrd_list (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("initrd_list: handle is closed");
    return _initrd_list (g, path);
  }
  private native String[] _initrd_list (long g, String path)
    throws LibGuestFSException;

  /**
   * mount a file using the loop device
   * <p>
   * This command lets you mount "file" (a filesystem image
   * in a file) on a mount point. It is entirely equivalent
   * to the command "mount -o loop file mountpoint".
   * <p>
   * @throws LibGuestFSException
   */
  public void mount_loop (String file, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_loop: handle is closed");
    _mount_loop (g, file, mountpoint);
  }
  private native void _mount_loop (long g, String file, String mountpoint)
    throws LibGuestFSException;

  /**
   * create a swap partition
   * <p>
   * Create a swap partition on "device".
   * <p>
   * @throws LibGuestFSException
   */
  public void mkswap (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkswap: handle is closed");
    _mkswap (g, device);
  }
  private native void _mkswap (long g, String device)
    throws LibGuestFSException;

  /**
   * create a swap partition with a label
   * <p>
   * Create a swap partition on "device" with label "label".
   * <p>
   * @throws LibGuestFSException
   */
  public void mkswap_L (String label, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkswap_L: handle is closed");
    _mkswap_L (g, label, device);
  }
  private native void _mkswap_L (long g, String label, String device)
    throws LibGuestFSException;

  /**
   * create a swap partition with an explicit UUID
   * <p>
   * Create a swap partition on "device" with UUID "uuid".
   * <p>
   * @throws LibGuestFSException
   */
  public void mkswap_U (String uuid, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkswap_U: handle is closed");
    _mkswap_U (g, uuid, device);
  }
  private native void _mkswap_U (long g, String uuid, String device)
    throws LibGuestFSException;

}
