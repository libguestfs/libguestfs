/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <caml/config.h>
#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/mlvalues.h>
#include <caml/signals.h>

#include <guestfs.h>

#include "guestfs_c.h"

/* Copy a hashtable of string pairs into an assoc-list.  We return
 * the list in reverse order, but hashtables aren't supposed to be
 * ordered anyway.
 */
static CAMLprim value
copy_table (char * const * argv)
{
  CAMLparam0 ();
  CAMLlocal5 (rv, pairv, kv, vv, cons);
  int i;

  rv = Val_int (0);
  for (i = 0; argv[i] != NULL; i += 2) {
    kv = caml_copy_string (argv[i]);
    vv = caml_copy_string (argv[i+1]);
    pairv = caml_alloc (2, 0);
    Store_field (pairv, 0, kv);
    Store_field (pairv, 1, vv);
    cons = caml_alloc (2, 0);
    Store_field (cons, 1, rv);
    rv = cons;
    Store_field (cons, 0, pairv);
  }

  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_pv (const struct guestfs_lvm_pv *pv)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (14, 0);
  v = caml_copy_string (pv->pv_name);
  Store_field (rv, 0, v);
  v = caml_alloc_string (32);
  memcpy (String_val (v), pv->pv_uuid, 32);
  Store_field (rv, 1, v);
  v = caml_copy_string (pv->pv_fmt);
  Store_field (rv, 2, v);
  v = caml_copy_int64 (pv->pv_size);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (pv->dev_size);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (pv->pv_free);
  Store_field (rv, 5, v);
  v = caml_copy_int64 (pv->pv_used);
  Store_field (rv, 6, v);
  v = caml_copy_string (pv->pv_attr);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (pv->pv_pe_count);
  Store_field (rv, 8, v);
  v = caml_copy_int64 (pv->pv_pe_alloc_count);
  Store_field (rv, 9, v);
  v = caml_copy_string (pv->pv_tags);
  Store_field (rv, 10, v);
  v = caml_copy_int64 (pv->pe_start);
  Store_field (rv, 11, v);
  v = caml_copy_int64 (pv->pv_mda_count);
  Store_field (rv, 12, v);
  v = caml_copy_int64 (pv->pv_mda_free);
  Store_field (rv, 13, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_pv_list (const struct guestfs_lvm_pv_list *pvs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (pvs->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (pvs->len, 0);
    for (i = 0; i < pvs->len; ++i) {
      v = copy_lvm_pv (&pvs->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

static CAMLprim value
copy_lvm_vg (const struct guestfs_lvm_vg *vg)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (19, 0);
  v = caml_copy_string (vg->vg_name);
  Store_field (rv, 0, v);
  v = caml_alloc_string (32);
  memcpy (String_val (v), vg->vg_uuid, 32);
  Store_field (rv, 1, v);
  v = caml_copy_string (vg->vg_fmt);
  Store_field (rv, 2, v);
  v = caml_copy_string (vg->vg_attr);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (vg->vg_size);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (vg->vg_free);
  Store_field (rv, 5, v);
  v = caml_copy_string (vg->vg_sysid);
  Store_field (rv, 6, v);
  v = caml_copy_int64 (vg->vg_extent_size);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (vg->vg_extent_count);
  Store_field (rv, 8, v);
  v = caml_copy_int64 (vg->vg_free_count);
  Store_field (rv, 9, v);
  v = caml_copy_int64 (vg->max_lv);
  Store_field (rv, 10, v);
  v = caml_copy_int64 (vg->max_pv);
  Store_field (rv, 11, v);
  v = caml_copy_int64 (vg->pv_count);
  Store_field (rv, 12, v);
  v = caml_copy_int64 (vg->lv_count);
  Store_field (rv, 13, v);
  v = caml_copy_int64 (vg->snap_count);
  Store_field (rv, 14, v);
  v = caml_copy_int64 (vg->vg_seqno);
  Store_field (rv, 15, v);
  v = caml_copy_string (vg->vg_tags);
  Store_field (rv, 16, v);
  v = caml_copy_int64 (vg->vg_mda_count);
  Store_field (rv, 17, v);
  v = caml_copy_int64 (vg->vg_mda_free);
  Store_field (rv, 18, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_vg_list (const struct guestfs_lvm_vg_list *vgs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (vgs->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (vgs->len, 0);
    for (i = 0; i < vgs->len; ++i) {
      v = copy_lvm_vg (&vgs->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

static CAMLprim value
copy_lvm_lv (const struct guestfs_lvm_lv *lv)
{
  CAMLparam0 ();
  CAMLlocal3 (rv, v, v2);

  rv = caml_alloc (16, 0);
  v = caml_copy_string (lv->lv_name);
  Store_field (rv, 0, v);
  v = caml_alloc_string (32);
  memcpy (String_val (v), lv->lv_uuid, 32);
  Store_field (rv, 1, v);
  v = caml_copy_string (lv->lv_attr);
  Store_field (rv, 2, v);
  v = caml_copy_int64 (lv->lv_major);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (lv->lv_minor);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (lv->lv_kernel_major);
  Store_field (rv, 5, v);
  v = caml_copy_int64 (lv->lv_kernel_minor);
  Store_field (rv, 6, v);
  v = caml_copy_int64 (lv->lv_size);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (lv->seg_count);
  Store_field (rv, 8, v);
  v = caml_copy_string (lv->origin);
  Store_field (rv, 9, v);
  if (lv->snap_percent >= 0) { /* Some snap_percent */
    v2 = caml_copy_double (lv->snap_percent);
    v = caml_alloc (1, 0);
    Store_field (v, 0, v2);
  } else /* None */
    v = Val_int (0);
  Store_field (rv, 10, v);
  if (lv->copy_percent >= 0) { /* Some copy_percent */
    v2 = caml_copy_double (lv->copy_percent);
    v = caml_alloc (1, 0);
    Store_field (v, 0, v2);
  } else /* None */
    v = Val_int (0);
  Store_field (rv, 11, v);
  v = caml_copy_string (lv->move_pv);
  Store_field (rv, 12, v);
  v = caml_copy_string (lv->lv_tags);
  Store_field (rv, 13, v);
  v = caml_copy_string (lv->mirror_log);
  Store_field (rv, 14, v);
  v = caml_copy_string (lv->modules);
  Store_field (rv, 15, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_lv_list (const struct guestfs_lvm_lv_list *lvs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (lvs->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (lvs->len, 0);
    for (i = 0; i < lvs->len; ++i) {
      v = copy_lvm_lv (&lvs->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

static CAMLprim value
copy_stat (const struct guestfs_stat *stat)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (13, 0);
  v = caml_copy_int64 (stat->dev);
  Store_field (rv, 0, v);
  v = caml_copy_int64 (stat->ino);
  Store_field (rv, 1, v);
  v = caml_copy_int64 (stat->mode);
  Store_field (rv, 2, v);
  v = caml_copy_int64 (stat->nlink);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (stat->uid);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (stat->gid);
  Store_field (rv, 5, v);
  v = caml_copy_int64 (stat->rdev);
  Store_field (rv, 6, v);
  v = caml_copy_int64 (stat->size);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (stat->blksize);
  Store_field (rv, 8, v);
  v = caml_copy_int64 (stat->blocks);
  Store_field (rv, 9, v);
  v = caml_copy_int64 (stat->atime);
  Store_field (rv, 10, v);
  v = caml_copy_int64 (stat->mtime);
  Store_field (rv, 11, v);
  v = caml_copy_int64 (stat->ctime);
  Store_field (rv, 12, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_statvfs (const struct guestfs_statvfs *statvfs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (11, 0);
  v = caml_copy_int64 (statvfs->bsize);
  Store_field (rv, 0, v);
  v = caml_copy_int64 (statvfs->frsize);
  Store_field (rv, 1, v);
  v = caml_copy_int64 (statvfs->blocks);
  Store_field (rv, 2, v);
  v = caml_copy_int64 (statvfs->bfree);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (statvfs->bavail);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (statvfs->files);
  Store_field (rv, 5, v);
  v = caml_copy_int64 (statvfs->ffree);
  Store_field (rv, 6, v);
  v = caml_copy_int64 (statvfs->favail);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (statvfs->fsid);
  Store_field (rv, 8, v);
  v = caml_copy_int64 (statvfs->flag);
  Store_field (rv, 9, v);
  v = caml_copy_int64 (statvfs->namemax);
  Store_field (rv, 10, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_dirent (const struct guestfs_dirent *dirent)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (3, 0);
  v = caml_copy_int64 (dirent->ino);
  Store_field (rv, 0, v);
  v = Val_int (dirent->ftyp);
  Store_field (rv, 1, v);
  v = caml_copy_string (dirent->name);
  Store_field (rv, 2, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_dirent_list (const struct guestfs_dirent_list *dirents)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (dirents->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (dirents->len, 0);
    for (i = 0; i < dirents->len; ++i) {
      v = copy_dirent (&dirents->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

CAMLprim value
ocaml_guestfs_test0 (value gv, value strv, value optstrv, value strlistv, value bv, value integerv, value fileinv, value fileoutv)
{
  CAMLparam5 (gv, strv, optstrv, strlistv, bv);
  CAMLxparam3 (integerv, fileinv, fileoutv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0: used handle after closing it");

  const char *str = String_val (strv);
  const char *optstr =
    optstrv != Val_int (0) ? String_val (Field (optstrv, 0)) : NULL;
  char **strlist = ocaml_guestfs_strings_val (g, strlistv);
  int b = Bool_val (bv);
  int integer = Int_val (integerv);
  const char *filein = String_val (fileinv);
  const char *fileout = String_val (fileoutv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_test0 (g, str, optstr, strlist, b, integer, filein, fileout);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (strlist);
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0_byte (value *argv, int argn)
{
  return ocaml_guestfs_test0 (argv[0], argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]);
}

CAMLprim value
ocaml_guestfs_test0rint (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rint: used handle after closing it");

  const char *val = String_val (valv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_test0rint (g, val);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0rint");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rinterr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rinterr: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_test0rinterr (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0rinterr");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rint64 (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rint64: used handle after closing it");

  const char *val = String_val (valv);
  int64_t r;

  caml_enter_blocking_section ();
  r = guestfs_test0rint64 (g, val);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0rint64");

  rv = caml_copy_int64 (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rint64err (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rint64err: used handle after closing it");

  int64_t r;

  caml_enter_blocking_section ();
  r = guestfs_test0rint64err (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0rint64err");

  rv = caml_copy_int64 (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rbool (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rbool: used handle after closing it");

  const char *val = String_val (valv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_test0rbool (g, val);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0rbool");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rboolerr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rboolerr: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_test0rboolerr (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "test0rboolerr");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rconststring (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rconststring: used handle after closing it");

  const char *val = String_val (valv);
  const char *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rconststring (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rconststring");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rconststringerr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rconststringerr: used handle after closing it");

  const char *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rconststringerr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rconststringerr");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstring (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstring: used handle after closing it");

  const char *val = String_val (valv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstring (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstring");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstringerr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstringerr: used handle after closing it");

  char *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstringerr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstringerr");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstringlist (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstringlist: used handle after closing it");

  const char *val = String_val (valv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstringlist (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstringlist");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstringlisterr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstringlisterr: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstringlisterr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstringlisterr");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rintbool (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rintbool: used handle after closing it");

  const char *val = String_val (valv);
  struct guestfs_int_bool *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rintbool (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rintbool");

  rv = caml_alloc (2, 0);
  Store_field (rv, 0, Val_int (r->i));
  Store_field (rv, 1, Val_bool (r->b));
  guestfs_free_int_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rintboolerr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rintboolerr: used handle after closing it");

  struct guestfs_int_bool *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rintboolerr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rintboolerr");

  rv = caml_alloc (2, 0);
  Store_field (rv, 0, Val_int (r->i));
  Store_field (rv, 1, Val_bool (r->b));
  guestfs_free_int_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rpvlist (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rpvlist: used handle after closing it");

  const char *val = String_val (valv);
  struct guestfs_lvm_pv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rpvlist (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rpvlist");

  rv = copy_lvm_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rpvlisterr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rpvlisterr: used handle after closing it");

  struct guestfs_lvm_pv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rpvlisterr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rpvlisterr");

  rv = copy_lvm_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rvglist (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rvglist: used handle after closing it");

  const char *val = String_val (valv);
  struct guestfs_lvm_vg_list *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rvglist (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rvglist");

  rv = copy_lvm_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rvglisterr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rvglisterr: used handle after closing it");

  struct guestfs_lvm_vg_list *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rvglisterr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rvglisterr");

  rv = copy_lvm_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rlvlist (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rlvlist: used handle after closing it");

  const char *val = String_val (valv);
  struct guestfs_lvm_lv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rlvlist (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rlvlist");

  rv = copy_lvm_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rlvlisterr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rlvlisterr: used handle after closing it");

  struct guestfs_lvm_lv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rlvlisterr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rlvlisterr");

  rv = copy_lvm_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstat (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstat: used handle after closing it");

  const char *val = String_val (valv);
  struct guestfs_stat *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstat (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstat");

  rv = copy_stat (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstaterr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstaterr: used handle after closing it");

  struct guestfs_stat *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstaterr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstaterr");

  rv = copy_stat (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstatvfs (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstatvfs: used handle after closing it");

  const char *val = String_val (valv);
  struct guestfs_statvfs *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstatvfs (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstatvfs");

  rv = copy_statvfs (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rstatvfserr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rstatvfserr: used handle after closing it");

  struct guestfs_statvfs *r;

  caml_enter_blocking_section ();
  r = guestfs_test0rstatvfserr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rstatvfserr");

  rv = copy_statvfs (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rhashtable (value gv, value valv)
{
  CAMLparam2 (gv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rhashtable: used handle after closing it");

  const char *val = String_val (valv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_test0rhashtable (g, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rhashtable");

  rv = copy_table (r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_test0rhashtableerr (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("test0rhashtableerr: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_test0rhashtableerr (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "test0rhashtableerr");

  rv = copy_table (r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_launch (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("launch: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_launch (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "launch");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_wait_ready (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("wait_ready: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_wait_ready (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "wait_ready");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_kill_subprocess (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("kill_subprocess: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_kill_subprocess (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "kill_subprocess");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_add_drive (value gv, value filenamev)
{
  CAMLparam2 (gv, filenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("add_drive: used handle after closing it");

  const char *filename = String_val (filenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_add_drive (g, filename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "add_drive");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_add_cdrom (value gv, value filenamev)
{
  CAMLparam2 (gv, filenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("add_cdrom: used handle after closing it");

  const char *filename = String_val (filenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_add_cdrom (g, filename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "add_cdrom");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_add_drive_ro (value gv, value filenamev)
{
  CAMLparam2 (gv, filenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("add_drive_ro: used handle after closing it");

  const char *filename = String_val (filenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_add_drive_ro (g, filename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "add_drive_ro");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_config (value gv, value qemuparamv, value qemuvaluev)
{
  CAMLparam3 (gv, qemuparamv, qemuvaluev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("config: used handle after closing it");

  const char *qemuparam = String_val (qemuparamv);
  const char *qemuvalue =
    qemuvaluev != Val_int (0) ? String_val (Field (qemuvaluev, 0)) : NULL;
  int r;

  caml_enter_blocking_section ();
  r = guestfs_config (g, qemuparam, qemuvalue);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "config");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_qemu (value gv, value qemuv)
{
  CAMLparam2 (gv, qemuv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_qemu: used handle after closing it");

  const char *qemu = String_val (qemuv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_qemu (g, qemu);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_qemu");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_qemu (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_qemu: used handle after closing it");

  const char *r;

  caml_enter_blocking_section ();
  r = guestfs_get_qemu (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "get_qemu");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_path (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_path: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_path (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_path");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_path (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_path: used handle after closing it");

  const char *r;

  caml_enter_blocking_section ();
  r = guestfs_get_path (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "get_path");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_append (value gv, value appendv)
{
  CAMLparam2 (gv, appendv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_append: used handle after closing it");

  const char *append = String_val (appendv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_append (g, append);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_append");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_append (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_append: used handle after closing it");

  const char *r;

  caml_enter_blocking_section ();
  r = guestfs_get_append (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "get_append");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_autosync (value gv, value autosyncv)
{
  CAMLparam2 (gv, autosyncv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_autosync: used handle after closing it");

  int autosync = Bool_val (autosyncv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_autosync (g, autosync);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_autosync");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_autosync (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_autosync: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_get_autosync (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "get_autosync");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_verbose (value gv, value verbosev)
{
  CAMLparam2 (gv, verbosev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_verbose: used handle after closing it");

  int verbose = Bool_val (verbosev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_verbose (g, verbose);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_verbose");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_verbose (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_verbose: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_get_verbose (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "get_verbose");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_ready (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_ready: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_ready (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_ready");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_config (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_config: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_config (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_config");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_launching (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_launching: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_launching (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_launching");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_busy (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_busy: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_busy (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_busy");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_state (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_state: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_get_state (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "get_state");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_busy (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_busy: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_busy (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_busy");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_ready (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_ready: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_ready (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_ready");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_end_busy (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("end_busy: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_end_busy (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "end_busy");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_memsize (value gv, value memsizev)
{
  CAMLparam2 (gv, memsizev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_memsize: used handle after closing it");

  int memsize = Int_val (memsizev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_memsize (g, memsize);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_memsize");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_memsize (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_memsize: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_get_memsize (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "get_memsize");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mount (value gv, value devicev, value mountpointv)
{
  CAMLparam3 (gv, devicev, mountpointv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mount: used handle after closing it");

  const char *device = String_val (devicev);
  const char *mountpoint = String_val (mountpointv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mount (g, device, mountpoint);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mount");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sync (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sync: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_sync (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "sync");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_touch (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("touch: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_touch (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "touch");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_cat (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("cat: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_cat (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "cat");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_ll (value gv, value directoryv)
{
  CAMLparam2 (gv, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("ll: used handle after closing it");

  const char *directory = String_val (directoryv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_ll (g, directory);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "ll");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_ls (value gv, value directoryv)
{
  CAMLparam2 (gv, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("ls: used handle after closing it");

  const char *directory = String_val (directoryv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_ls (g, directory);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "ls");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_list_devices (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("list_devices: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_list_devices (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "list_devices");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_list_partitions (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("list_partitions: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_list_partitions (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "list_partitions");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvs (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvs: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_pvs (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "pvs");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgs (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgs: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_vgs (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "vgs");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvs (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvs: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_lvs (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "lvs");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvs_full (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvs_full: used handle after closing it");

  struct guestfs_lvm_pv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_pvs_full (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "pvs_full");

  rv = copy_lvm_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgs_full (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgs_full: used handle after closing it");

  struct guestfs_lvm_vg_list *r;

  caml_enter_blocking_section ();
  r = guestfs_vgs_full (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "vgs_full");

  rv = copy_lvm_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvs_full (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvs_full: used handle after closing it");

  struct guestfs_lvm_lv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_lvs_full (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "lvs_full");

  rv = copy_lvm_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_read_lines (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("read_lines: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_read_lines (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "read_lines");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_init (value gv, value rootv, value flagsv)
{
  CAMLparam3 (gv, rootv, flagsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_init: used handle after closing it");

  const char *root = String_val (rootv);
  int flags = Int_val (flagsv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_init (g, root, flags);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_init");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_close (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_close: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_close (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_close");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_defvar (value gv, value namev, value exprv)
{
  CAMLparam3 (gv, namev, exprv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_defvar: used handle after closing it");

  const char *name = String_val (namev);
  const char *expr =
    exprv != Val_int (0) ? String_val (Field (exprv, 0)) : NULL;
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_defvar (g, name, expr);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_defvar");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_defnode (value gv, value namev, value exprv, value valv)
{
  CAMLparam4 (gv, namev, exprv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_defnode: used handle after closing it");

  const char *name = String_val (namev);
  const char *expr = String_val (exprv);
  const char *val = String_val (valv);
  struct guestfs_int_bool *r;

  caml_enter_blocking_section ();
  r = guestfs_aug_defnode (g, name, expr, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_defnode");

  rv = caml_alloc (2, 0);
  Store_field (rv, 0, Val_int (r->i));
  Store_field (rv, 1, Val_bool (r->b));
  guestfs_free_int_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_get (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_get: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_aug_get (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_get");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_set (value gv, value pathv, value valv)
{
  CAMLparam3 (gv, pathv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_set: used handle after closing it");

  const char *path = String_val (pathv);
  const char *val = String_val (valv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_set (g, path, val);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_set");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_insert (value gv, value pathv, value labelv, value beforev)
{
  CAMLparam4 (gv, pathv, labelv, beforev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_insert: used handle after closing it");

  const char *path = String_val (pathv);
  const char *label = String_val (labelv);
  int before = Bool_val (beforev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_insert (g, path, label, before);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_insert");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_rm (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_rm: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_rm (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_rm");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_mv (value gv, value srcv, value destv)
{
  CAMLparam3 (gv, srcv, destv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_mv: used handle after closing it");

  const char *src = String_val (srcv);
  const char *dest = String_val (destv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_mv (g, src, dest);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_mv");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_match (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_match: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_aug_match (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_match");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_save (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_save: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_save (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_save");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_load (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_load: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_load (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_load");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_ls (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_ls: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_aug_ls (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_ls");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_rm (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("rm: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_rm (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "rm");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_rmdir (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("rmdir: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_rmdir (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "rmdir");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_rm_rf (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("rm_rf: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_rm_rf (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "rm_rf");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkdir (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkdir: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkdir (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkdir");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkdir_p (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkdir_p: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkdir_p (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkdir_p");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_chmod (value gv, value modev, value pathv)
{
  CAMLparam3 (gv, modev, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("chmod: used handle after closing it");

  int mode = Int_val (modev);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_chmod (g, mode, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "chmod");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_chown (value gv, value ownerv, value groupv, value pathv)
{
  CAMLparam4 (gv, ownerv, groupv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("chown: used handle after closing it");

  int owner = Int_val (ownerv);
  int group = Int_val (groupv);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_chown (g, owner, group, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "chown");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_exists (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("exists: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_exists (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "exists");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_file (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_file: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_file (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_file");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_dir (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_dir: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_dir (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_dir");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvcreate (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvcreate: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_pvcreate (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "pvcreate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgcreate (value gv, value volgroupv, value physvolsv)
{
  CAMLparam3 (gv, volgroupv, physvolsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgcreate: used handle after closing it");

  const char *volgroup = String_val (volgroupv);
  char **physvols = ocaml_guestfs_strings_val (g, physvolsv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_vgcreate (g, volgroup, physvols);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (physvols);
  if (r == -1)
    ocaml_guestfs_raise_error (g, "vgcreate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvcreate (value gv, value logvolv, value volgroupv, value mbytesv)
{
  CAMLparam4 (gv, logvolv, volgroupv, mbytesv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvcreate: used handle after closing it");

  const char *logvol = String_val (logvolv);
  const char *volgroup = String_val (volgroupv);
  int mbytes = Int_val (mbytesv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_lvcreate (g, logvol, volgroup, mbytes);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "lvcreate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkfs (value gv, value fstypev, value devicev)
{
  CAMLparam3 (gv, fstypev, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkfs: used handle after closing it");

  const char *fstype = String_val (fstypev);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkfs (g, fstype, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkfs");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk (value gv, value devicev, value cylsv, value headsv, value sectorsv, value linesv)
{
  CAMLparam5 (gv, devicev, cylsv, headsv, sectorsv);
  CAMLxparam1 (linesv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sfdisk: used handle after closing it");

  const char *device = String_val (devicev);
  int cyls = Int_val (cylsv);
  int heads = Int_val (headsv);
  int sectors = Int_val (sectorsv);
  char **lines = ocaml_guestfs_strings_val (g, linesv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_sfdisk (g, device, cyls, heads, sectors, lines);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (lines);
  if (r == -1)
    ocaml_guestfs_raise_error (g, "sfdisk");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk_byte (value *argv, int argn)
{
  return ocaml_guestfs_sfdisk (argv[0], argv[0], argv[1], argv[2], argv[3], argv[4]);
}

CAMLprim value
ocaml_guestfs_write_file (value gv, value pathv, value contentv, value sizev)
{
  CAMLparam4 (gv, pathv, contentv, sizev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("write_file: used handle after closing it");

  const char *path = String_val (pathv);
  const char *content = String_val (contentv);
  int size = Int_val (sizev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_write_file (g, path, content, size);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "write_file");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_umount (value gv, value pathordevicev)
{
  CAMLparam2 (gv, pathordevicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("umount: used handle after closing it");

  const char *pathordevice = String_val (pathordevicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_umount (g, pathordevice);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "umount");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mounts (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mounts: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_mounts (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "mounts");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_umount_all (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("umount_all: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_umount_all (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "umount_all");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvm_remove_all (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvm_remove_all: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_lvm_remove_all (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "lvm_remove_all");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_file (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("file: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_file (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "file");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_command (value gv, value argumentsv)
{
  CAMLparam2 (gv, argumentsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("command: used handle after closing it");

  char **arguments = ocaml_guestfs_strings_val (g, argumentsv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_command (g, arguments);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (arguments);
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "command");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_command_lines (value gv, value argumentsv)
{
  CAMLparam2 (gv, argumentsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("command_lines: used handle after closing it");

  char **arguments = ocaml_guestfs_strings_val (g, argumentsv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_command_lines (g, arguments);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (arguments);
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "command_lines");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_stat (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("stat: used handle after closing it");

  const char *path = String_val (pathv);
  struct guestfs_stat *r;

  caml_enter_blocking_section ();
  r = guestfs_stat (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "stat");

  rv = copy_stat (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lstat (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lstat: used handle after closing it");

  const char *path = String_val (pathv);
  struct guestfs_stat *r;

  caml_enter_blocking_section ();
  r = guestfs_lstat (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "lstat");

  rv = copy_stat (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_statvfs (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("statvfs: used handle after closing it");

  const char *path = String_val (pathv);
  struct guestfs_statvfs *r;

  caml_enter_blocking_section ();
  r = guestfs_statvfs (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "statvfs");

  rv = copy_statvfs (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tune2fs_l (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tune2fs_l: used handle after closing it");

  const char *device = String_val (devicev);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_tune2fs_l (g, device);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "tune2fs_l");

  rv = copy_table (r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_setro (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_setro: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_setro (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_setro");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_setrw (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_setrw: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_setrw (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_setrw");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_getro (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_getro: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_getro (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_getro");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_getss (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_getss: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_getss (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_getss");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_getbsz (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_getbsz: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_getbsz (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_getbsz");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_setbsz (value gv, value devicev, value blocksizev)
{
  CAMLparam3 (gv, devicev, blocksizev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_setbsz: used handle after closing it");

  const char *device = String_val (devicev);
  int blocksize = Int_val (blocksizev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_setbsz (g, device, blocksize);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_setbsz");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_getsz (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_getsz: used handle after closing it");

  const char *device = String_val (devicev);
  int64_t r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_getsz (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_getsz");

  rv = caml_copy_int64 (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_getsize64 (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_getsize64: used handle after closing it");

  const char *device = String_val (devicev);
  int64_t r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_getsize64 (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_getsize64");

  rv = caml_copy_int64 (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_flushbufs (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_flushbufs: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_flushbufs (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_flushbufs");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_blockdev_rereadpt (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("blockdev_rereadpt: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_blockdev_rereadpt (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "blockdev_rereadpt");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_upload (value gv, value filenamev, value remotefilenamev)
{
  CAMLparam3 (gv, filenamev, remotefilenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("upload: used handle after closing it");

  const char *filename = String_val (filenamev);
  const char *remotefilename = String_val (remotefilenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_upload (g, filename, remotefilename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "upload");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_download (value gv, value remotefilenamev, value filenamev)
{
  CAMLparam3 (gv, remotefilenamev, filenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("download: used handle after closing it");

  const char *remotefilename = String_val (remotefilenamev);
  const char *filename = String_val (filenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_download (g, remotefilename, filename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "download");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_checksum (value gv, value csumtypev, value pathv)
{
  CAMLparam3 (gv, csumtypev, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("checksum: used handle after closing it");

  const char *csumtype = String_val (csumtypev);
  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_checksum (g, csumtype, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "checksum");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tar_in (value gv, value tarfilev, value directoryv)
{
  CAMLparam3 (gv, tarfilev, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tar_in: used handle after closing it");

  const char *tarfile = String_val (tarfilev);
  const char *directory = String_val (directoryv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_tar_in (g, tarfile, directory);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "tar_in");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tar_out (value gv, value directoryv, value tarfilev)
{
  CAMLparam3 (gv, directoryv, tarfilev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tar_out: used handle after closing it");

  const char *directory = String_val (directoryv);
  const char *tarfile = String_val (tarfilev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_tar_out (g, directory, tarfile);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "tar_out");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tgz_in (value gv, value tarballv, value directoryv)
{
  CAMLparam3 (gv, tarballv, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tgz_in: used handle after closing it");

  const char *tarball = String_val (tarballv);
  const char *directory = String_val (directoryv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_tgz_in (g, tarball, directory);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "tgz_in");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tgz_out (value gv, value directoryv, value tarballv)
{
  CAMLparam3 (gv, directoryv, tarballv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tgz_out: used handle after closing it");

  const char *directory = String_val (directoryv);
  const char *tarball = String_val (tarballv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_tgz_out (g, directory, tarball);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "tgz_out");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mount_ro (value gv, value devicev, value mountpointv)
{
  CAMLparam3 (gv, devicev, mountpointv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mount_ro: used handle after closing it");

  const char *device = String_val (devicev);
  const char *mountpoint = String_val (mountpointv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mount_ro (g, device, mountpoint);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mount_ro");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mount_options (value gv, value optionsv, value devicev, value mountpointv)
{
  CAMLparam4 (gv, optionsv, devicev, mountpointv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mount_options: used handle after closing it");

  const char *options = String_val (optionsv);
  const char *device = String_val (devicev);
  const char *mountpoint = String_val (mountpointv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mount_options (g, options, device, mountpoint);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mount_options");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mount_vfs (value gv, value optionsv, value vfstypev, value devicev, value mountpointv)
{
  CAMLparam5 (gv, optionsv, vfstypev, devicev, mountpointv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mount_vfs: used handle after closing it");

  const char *options = String_val (optionsv);
  const char *vfstype = String_val (vfstypev);
  const char *device = String_val (devicev);
  const char *mountpoint = String_val (mountpointv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mount_vfs (g, options, vfstype, device, mountpoint);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mount_vfs");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_debug (value gv, value subcmdv, value extraargsv)
{
  CAMLparam3 (gv, subcmdv, extraargsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("debug: used handle after closing it");

  const char *subcmd = String_val (subcmdv);
  char **extraargs = ocaml_guestfs_strings_val (g, extraargsv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_debug (g, subcmd, extraargs);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (extraargs);
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "debug");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvremove (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvremove: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_lvremove (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "lvremove");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgremove (value gv, value vgnamev)
{
  CAMLparam2 (gv, vgnamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgremove: used handle after closing it");

  const char *vgname = String_val (vgnamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_vgremove (g, vgname);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "vgremove");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvremove (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvremove: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_pvremove (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "pvremove");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_e2label (value gv, value devicev, value labelv)
{
  CAMLparam3 (gv, devicev, labelv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_e2label: used handle after closing it");

  const char *device = String_val (devicev);
  const char *label = String_val (labelv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_e2label (g, device, label);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_e2label");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_e2label (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_e2label: used handle after closing it");

  const char *device = String_val (devicev);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_get_e2label (g, device);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "get_e2label");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_e2uuid (value gv, value devicev, value uuidv)
{
  CAMLparam3 (gv, devicev, uuidv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_e2uuid: used handle after closing it");

  const char *device = String_val (devicev);
  const char *uuid = String_val (uuidv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_e2uuid (g, device, uuid);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_e2uuid");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_e2uuid (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_e2uuid: used handle after closing it");

  const char *device = String_val (devicev);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_get_e2uuid (g, device);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "get_e2uuid");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_fsck (value gv, value fstypev, value devicev)
{
  CAMLparam3 (gv, fstypev, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("fsck: used handle after closing it");

  const char *fstype = String_val (fstypev);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_fsck (g, fstype, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "fsck");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_zero (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("zero: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_zero (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "zero");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_grub_install (value gv, value rootv, value devicev)
{
  CAMLparam3 (gv, rootv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("grub_install: used handle after closing it");

  const char *root = String_val (rootv);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_grub_install (g, root, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "grub_install");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_cp (value gv, value srcv, value destv)
{
  CAMLparam3 (gv, srcv, destv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("cp: used handle after closing it");

  const char *src = String_val (srcv);
  const char *dest = String_val (destv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_cp (g, src, dest);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "cp");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_cp_a (value gv, value srcv, value destv)
{
  CAMLparam3 (gv, srcv, destv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("cp_a: used handle after closing it");

  const char *src = String_val (srcv);
  const char *dest = String_val (destv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_cp_a (g, src, dest);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "cp_a");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mv (value gv, value srcv, value destv)
{
  CAMLparam3 (gv, srcv, destv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mv: used handle after closing it");

  const char *src = String_val (srcv);
  const char *dest = String_val (destv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mv (g, src, dest);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mv");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_drop_caches (value gv, value whattodropv)
{
  CAMLparam2 (gv, whattodropv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("drop_caches: used handle after closing it");

  int whattodrop = Int_val (whattodropv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_drop_caches (g, whattodrop);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "drop_caches");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_dmesg (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("dmesg: used handle after closing it");

  char *r;

  caml_enter_blocking_section ();
  r = guestfs_dmesg (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "dmesg");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_ping_daemon (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("ping_daemon: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_ping_daemon (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "ping_daemon");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_equal (value gv, value file1v, value file2v)
{
  CAMLparam3 (gv, file1v, file2v);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("equal: used handle after closing it");

  const char *file1 = String_val (file1v);
  const char *file2 = String_val (file2v);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_equal (g, file1, file2);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "equal");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_strings (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("strings: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_strings (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "strings");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_strings_e (value gv, value encodingv, value pathv)
{
  CAMLparam3 (gv, encodingv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("strings_e: used handle after closing it");

  const char *encoding = String_val (encodingv);
  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_strings_e (g, encoding, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "strings_e");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_hexdump (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("hexdump: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_hexdump (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "hexdump");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_zerofree (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("zerofree: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_zerofree (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "zerofree");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvresize (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvresize: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_pvresize (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "pvresize");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk_N (value gv, value devicev, value partnumv, value cylsv, value headsv, value sectorsv, value linev)
{
  CAMLparam5 (gv, devicev, partnumv, cylsv, headsv);
  CAMLxparam2 (sectorsv, linev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sfdisk_N: used handle after closing it");

  const char *device = String_val (devicev);
  int partnum = Int_val (partnumv);
  int cyls = Int_val (cylsv);
  int heads = Int_val (headsv);
  int sectors = Int_val (sectorsv);
  const char *line = String_val (linev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_sfdisk_N (g, device, partnum, cyls, heads, sectors, line);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "sfdisk_N");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk_N_byte (value *argv, int argn)
{
  return ocaml_guestfs_sfdisk_N (argv[0], argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
}

CAMLprim value
ocaml_guestfs_sfdisk_l (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sfdisk_l: used handle after closing it");

  const char *device = String_val (devicev);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_sfdisk_l (g, device);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "sfdisk_l");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk_kernel_geometry (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sfdisk_kernel_geometry: used handle after closing it");

  const char *device = String_val (devicev);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_sfdisk_kernel_geometry (g, device);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "sfdisk_kernel_geometry");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk_disk_geometry (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sfdisk_disk_geometry: used handle after closing it");

  const char *device = String_val (devicev);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_sfdisk_disk_geometry (g, device);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "sfdisk_disk_geometry");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vg_activate_all (value gv, value activatev)
{
  CAMLparam2 (gv, activatev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vg_activate_all: used handle after closing it");

  int activate = Bool_val (activatev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_vg_activate_all (g, activate);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "vg_activate_all");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vg_activate (value gv, value activatev, value volgroupsv)
{
  CAMLparam3 (gv, activatev, volgroupsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vg_activate: used handle after closing it");

  int activate = Bool_val (activatev);
  char **volgroups = ocaml_guestfs_strings_val (g, volgroupsv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_vg_activate (g, activate, volgroups);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (volgroups);
  if (r == -1)
    ocaml_guestfs_raise_error (g, "vg_activate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvresize (value gv, value devicev, value mbytesv)
{
  CAMLparam3 (gv, devicev, mbytesv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvresize: used handle after closing it");

  const char *device = String_val (devicev);
  int mbytes = Int_val (mbytesv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_lvresize (g, device, mbytes);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "lvresize");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_resize2fs (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("resize2fs: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_resize2fs (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "resize2fs");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_find (value gv, value directoryv)
{
  CAMLparam2 (gv, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("find: used handle after closing it");

  const char *directory = String_val (directoryv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_find (g, directory);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "find");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_e2fsck_f (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("e2fsck_f: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_e2fsck_f (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "e2fsck_f");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sleep (value gv, value secsv)
{
  CAMLparam2 (gv, secsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sleep: used handle after closing it");

  int secs = Int_val (secsv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_sleep (g, secs);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "sleep");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_ntfs_3g_probe (value gv, value rwv, value devicev)
{
  CAMLparam3 (gv, rwv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("ntfs_3g_probe: used handle after closing it");

  int rw = Bool_val (rwv);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_ntfs_3g_probe (g, rw, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "ntfs_3g_probe");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sh (value gv, value commandv)
{
  CAMLparam2 (gv, commandv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sh: used handle after closing it");

  const char *command = String_val (commandv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_sh (g, command);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "sh");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sh_lines (value gv, value commandv)
{
  CAMLparam2 (gv, commandv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sh_lines: used handle after closing it");

  const char *command = String_val (commandv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_sh_lines (g, command);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "sh_lines");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_glob_expand (value gv, value patternv)
{
  CAMLparam2 (gv, patternv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("glob_expand: used handle after closing it");

  const char *pattern = String_val (patternv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_glob_expand (g, pattern);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "glob_expand");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_scrub_device (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("scrub_device: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_scrub_device (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "scrub_device");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_scrub_file (value gv, value filev)
{
  CAMLparam2 (gv, filev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("scrub_file: used handle after closing it");

  const char *file = String_val (filev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_scrub_file (g, file);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "scrub_file");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_scrub_freespace (value gv, value dirv)
{
  CAMLparam2 (gv, dirv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("scrub_freespace: used handle after closing it");

  const char *dir = String_val (dirv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_scrub_freespace (g, dir);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "scrub_freespace");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkdtemp (value gv, value templatev)
{
  CAMLparam2 (gv, templatev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkdtemp: used handle after closing it");

  const char *template = String_val (templatev);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_mkdtemp (g, template);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "mkdtemp");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_wc_l (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("wc_l: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_wc_l (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "wc_l");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_wc_w (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("wc_w: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_wc_w (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "wc_w");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_wc_c (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("wc_c: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_wc_c (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "wc_c");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_head (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("head: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_head (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "head");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_head_n (value gv, value nrlinesv, value pathv)
{
  CAMLparam3 (gv, nrlinesv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("head_n: used handle after closing it");

  int nrlines = Int_val (nrlinesv);
  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_head_n (g, nrlines, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "head_n");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tail (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tail: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_tail (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "tail");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_tail_n (value gv, value nrlinesv, value pathv)
{
  CAMLparam3 (gv, nrlinesv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("tail_n: used handle after closing it");

  int nrlines = Int_val (nrlinesv);
  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_tail_n (g, nrlines, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "tail_n");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_df (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("df: used handle after closing it");

  char *r;

  caml_enter_blocking_section ();
  r = guestfs_df (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "df");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_df_h (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("df_h: used handle after closing it");

  char *r;

  caml_enter_blocking_section ();
  r = guestfs_df_h (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "df_h");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_du (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("du: used handle after closing it");

  const char *path = String_val (pathv);
  int64_t r;

  caml_enter_blocking_section ();
  r = guestfs_du (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "du");

  rv = caml_copy_int64 (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_initrd_list (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("initrd_list: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_initrd_list (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "initrd_list");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mount_loop (value gv, value filev, value mountpointv)
{
  CAMLparam3 (gv, filev, mountpointv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mount_loop: used handle after closing it");

  const char *file = String_val (filev);
  const char *mountpoint = String_val (mountpointv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mount_loop (g, file, mountpoint);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mount_loop");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkswap (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkswap: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkswap (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkswap");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkswap_L (value gv, value labelv, value devicev)
{
  CAMLparam3 (gv, labelv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkswap_L: used handle after closing it");

  const char *label = String_val (labelv);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkswap_L (g, label, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkswap_L");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkswap_U (value gv, value uuidv, value devicev)
{
  CAMLparam3 (gv, uuidv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkswap_U: used handle after closing it");

  const char *uuid = String_val (uuidv);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkswap_U (g, uuid, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkswap_U");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mknod (value gv, value modev, value devmajorv, value devminorv, value pathv)
{
  CAMLparam5 (gv, modev, devmajorv, devminorv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mknod: used handle after closing it");

  int mode = Int_val (modev);
  int devmajor = Int_val (devmajorv);
  int devminor = Int_val (devminorv);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mknod (g, mode, devmajor, devminor, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mknod");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkfifo (value gv, value modev, value pathv)
{
  CAMLparam3 (gv, modev, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkfifo: used handle after closing it");

  int mode = Int_val (modev);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkfifo (g, mode, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkfifo");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mknod_b (value gv, value modev, value devmajorv, value devminorv, value pathv)
{
  CAMLparam5 (gv, modev, devmajorv, devminorv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mknod_b: used handle after closing it");

  int mode = Int_val (modev);
  int devmajor = Int_val (devmajorv);
  int devminor = Int_val (devminorv);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mknod_b (g, mode, devmajor, devminor, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mknod_b");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mknod_c (value gv, value modev, value devmajorv, value devminorv, value pathv)
{
  CAMLparam5 (gv, modev, devmajorv, devminorv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mknod_c: used handle after closing it");

  int mode = Int_val (modev);
  int devmajor = Int_val (devmajorv);
  int devminor = Int_val (devminorv);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mknod_c (g, mode, devmajor, devminor, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mknod_c");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_umask (value gv, value maskv)
{
  CAMLparam2 (gv, maskv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("umask: used handle after closing it");

  int mask = Int_val (maskv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_umask (g, mask);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "umask");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_readdir (value gv, value dirv)
{
  CAMLparam2 (gv, dirv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("readdir: used handle after closing it");

  const char *dir = String_val (dirv);
  struct guestfs_dirent_list *r;

  caml_enter_blocking_section ();
  r = guestfs_readdir (g, dir);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "readdir");

  rv = copy_dirent_list (r);
  guestfs_free_dirent_list (r);
  CAMLreturn (rv);
}

